
# 深度优先搜索与广度优先搜索解决岛屿数量问题的详细分析

搜索算法是解决图形问题的关键工具，特别是在处理连通性问题时。以下是对深度优先搜索(DFS)和广度优先搜索(BFS)两种经典算法的详细解析，以及它们如何应用于解决LeetCode 200岛屿数量问题。

## 一、深度优先搜索(DFS)算法思想

### 1. DFS核心思想

深度优先搜索的核心思想是：**"一条路走到黑"**。它尽可能深地探索图的分支，直到无路可走时才回溯到前一个节点，继续探索其他路径。

### 2. DFS基本特性

- **方向性**：优先探索深度而非广度
- **实现方式**：通常使用递归或显式栈
- **空间复杂度**：最坏情况下为O(V)，其中V是节点数量
- **应用场景**：适合解决连通性问题、拓扑排序、寻找路径等

### 3. DFS解决岛屿问题的流程

让我们以一个简单的例子来说明DFS的工作原理：

```
[
  ["1","1","0"],
  ["1","0","0"],
  ["0","0","1"]
]
```

**DFS执行步骤：**

1. **初始化**：
   - 创建一个计数器count=0，用于统计岛屿数量
   - 遍历二维网格的每个单元格

2. **发现陆地**：
   - 当在位置(0,0)发现陆地('1')时，将count增加1（count=1）
   - 开始DFS探索与该陆地相连的所有陆地

3. **递归标记过程**：
   - 将当前单元格(0,0)标记为已访问（修改为'0'）
   - 递归探索四个方向：上、下、左、右
   - 位置(0,1)是陆地，标记为已访问，继续递归
   - 位置(1,0)是陆地，标记为已访问，继续递归
   - 其他相邻位置要么是水，要么超出边界，不再继续

4. **完成第一个岛屿标记**：
   - 当递归完成后，第一个岛屿的所有部分已被标记
   ```
   [
     ["0","0","0"],
     ["0","0","0"],
     ["0","0","1"]
   ]
   ```

5. **继续遍历**：
   - 继续遍历剩余的单元格
   - 在位置(2,2)发现新的陆地，count增加1（count=2）
   - 对这个新岛屿执行DFS，标记完成后所有单元格都变为'0'

6. **返回结果**：
   - 遍历完成后，返回count=2作为岛屿数量

### 4. DFS代码实现与详解

```javascript
/**
 * 使用DFS解决岛屿数量问题
 * @param {character[][]} grid - 二维网格
 * @return {number} - 岛屿数量
 */
function numIslandsDFS(grid) {
    // 处理边界情况
    if (!grid || grid.length === 0) return 0;
    
    const rows = grid.length;
    const cols = grid[0].length;
    let count = 0;  // 岛屿计数器
    
    // DFS函数，用于标记相连的陆地
    function dfs(row, col) {
        // 基础情况：超出边界或当前位置是水
        if (row < 0 || col < 0 || row >= rows || col >= cols || grid[row][col] === '0') {
            return;
        }
        
        // 标记当前位置为已访问（变为水）
        grid[row][col] = '0';
        
        // 递归探索四个方向
        dfs(row - 1, col);  // 上
        dfs(row + 1, col);  // 下
        dfs(row, col - 1);  // 左
        dfs(row, col + 1);  // 右
    }
    
    // 遍历整个网格
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (grid[i][j] === '1') {
                count++;    // 发现新岛屿
                dfs(i, j);  // 标记整个岛屿
            }
        }
    }
    
    return count;
}
```

**代码执行流程图解**：

对于输入：
```
[
  ["1","1","0"],
  ["1","0","0"],
  ["0","0","1"]
]
```

执行流程如下：

1. 遍历到(0,0)，发现是'1'，count=1
2. 执行dfs(0,0)
   - 标记(0,0)为'0'
   - 递归调用dfs(0,-1)、dfs(-1,0)均无效（超出边界）
   - 递归调用dfs(0,1)有效，进入dfs(0,1)
     - 标记(0,1)为'0'
     - 递归调用...
   - 递归调用dfs(1,0)有效，进入dfs(1,0)
     - 标记(1,0)为'0'
     - 递归调用...
3. 第一个DFS结束后，网格变为：
   ```
   [
     ["0","0","0"],
     ["0","0","0"],
     ["0","0","1"]
   ]
   ```
4. 继续遍历至(2,2)，发现是'1'，count=2
5. 执行dfs(2,2)
   - 标记(2,2)为'0'
   - 所有递归调用均无效
6. 最终返回count=2

## 二、广度优先搜索(BFS)算法思想

### 1. BFS核心思想

广度优先搜索的核心思想是：**"一层一层地扩展"**。它优先访问离起点近的节点，然后再访问离起点远的节点，像水波纹一样向外扩散。

### 2. BFS基本特性

- **方向性**：优先探索广度而非深度
- **实现方式**：通常使用队列
- **空间复杂度**：最坏情况下为O(W)，其中W是最宽层的节点数
- **应用场景**：适合寻找最短路径、层序遍历等

### 3. BFS解决岛屿问题的流程

使用相同的例子：

```
[
  ["1","1","0"],
  ["1","0","0"],
  ["0","0","1"]
]
```

**BFS执行步骤：**

1. **初始化**：
   - 创建一个计数器count=0，用于统计岛屿数量
   - 创建一个队列，用于BFS遍历
   - 遍历二维网格的每个单元格

2. **发现陆地**：
   - 当在位置(0,0)发现陆地('1')时，将count增加1（count=1）
   - 将(0,0)加入队列，并标记为已访问（修改为'0'）

3. **队列处理过程**：
   - 从队列中取出(0,0)
   - 检查四个方向：上、下、左、右
   - 位置(0,1)和(1,0)是陆地，加入队列并标记为已访问
   - 继续从队列取出(0,1)，检查其四个方向
   - 继续从队列取出(1,0)，检查其四个方向
   - 当队列为空时，表示整个连通区域已被处理完

4. **完成第一个岛屿标记**：
   - BFS遍历完成后，第一个岛屿的所有部分已被标记
   ```
   [
     ["0","0","0"],
     ["0","0","0"],
     ["0","0","1"]
   ]
   ```

5. **继续遍历**：
   - 继续遍历剩余的单元格
   - 在位置(2,2)发现新的陆地，count增加1（count=2）
   - 对这个新岛屿执行BFS，标记完成后所有单元格都变为'0'

6. **返回结果**：
   - 遍历完成后，返回count=2作为岛屿数量

### 4. BFS代码实现与详解

```javascript
/**
 * 使用BFS解决岛屿数量问题
 * @param {character[][]} grid - 二维网格
 * @return {number} - 岛屿数量
 */
function numIslandsBFS(grid) {
    // 处理边界情况
    if (!grid || grid.length === 0) return 0;
    
    const rows = grid.length;
    const cols = grid[0].length;
    let count = 0;
    
    // 方向数组：上、下、左、右
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    
    // BFS函数，用于标记相连的陆地
    function bfs(row, col) {
        // 创建队列并将起始点加入
        const queue = [[row, col]];
        grid[row][col] = '0';  // 标记起始点为已访问
        
        // 当队列不为空时继续处理
        while (queue.length > 0) {
            // 取出队首元素
            const [currRow, currCol] = queue.shift();
            
            // 检查四个方向
            for (const [dr, dc] of directions) {
                const newRow = currRow + dr;
                const newCol = currCol + dc;
                
                // 检查新位置是否有效且为陆地
                if (newRow >= 0 && newCol >= 0 && newRow < rows && newCol < cols && grid[newRow][newCol] === '1') {
                    queue.push([newRow, newCol]);  // 加入队列
                    grid[newRow][newCol] = '0';    // 标记为已访问
                }
            }
        }
    }
    
    // 遍历整个网格
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (grid[i][j] === '1') {
                count++;    // 发现新岛屿
                bfs(i, j);  // 标记整个岛屿
            }
        }
    }
    
    return count;
}
```

**代码执行流程图解**：

对于相同的输入，BFS执行流程：

1. 遍历到(0,0)，发现是'1'，count=1
2. 执行bfs(0,0)
   - 将(0,0)加入队列，并标记为'0'
   - 从队列取出(0,0)，检查四个方向
   - 发现有效的陆地(0,1)和(1,0)，加入队列并标记为'0'
   - 从队列取出(0,1)，检查四个方向
   - 从队列取出(1,0)，检查四个方向
   - 队列为空，BFS结束
3. 第一个BFS结束后，网格变为：
   ```
   [
     ["0","0","0"],
     ["0","0","0"],
     ["0","0","1"]
   ]
   ```
4. 继续遍历至(2,2)，发现是'1'，count=2
5. 执行bfs(2,2)
   - 将(2,2)加入队列，并标记为'0'
   - 从队列取出(2,2)，检查四个方向都无效
   - 队列为空，BFS结束
6. 最终返回count=2

## 三、DFS与BFS的对比与选择

### 1. 执行过程对比

**DFS的执行特点**：
- 从起点开始，沿一条路径一直探索到底
- 到底后才回溯，尝试其他路径
- 执行路径像是在画"树"的分支

**BFS的执行特点**：
- 从起点开始，先探索所有相邻节点
- 然后再探索下一层节点
- 执行路径像是水波纹扩散

### 2. 适用场景比较

| 特性 | DFS | BFS |
|------|-----|-----|
| 寻找路径 | 适合找到所有可能的路径 | 适合找到最短路径 |
| 内存消耗 | 与最深路径成正比 | 与最宽层成正比 |
| 实现复杂度 | 递归实现较简单 | 需要额外的队列数据结构 |
| 完整性 | 可能陷入很深的分支 | 保证找到最近的解 |
| 适用问题 | 拓扑排序、连通性检测、迷宫生成 | 最短路径、层序遍历、网络爬虫 |

### 3. 在岛屿问题中的选择

- **使用DFS的优势**：
  - 代码实现更简洁，递归方式直观
  - 节省了显式队列的空间（使用系统的调用栈）
  
- **使用BFS的优势**：
  - 避免递归栈溢出的风险
  - 对于大规模网格更安全
  - 在需要计算距离的变种问题中更有优势

## 四、总结

深度优先搜索(DFS)和广度优先搜索(BFS)是解决岛屿数量问题的两种有效方法，它们的核心思想分别是"深入探索"和"层层扩展"。在实现上，DFS通常使用递归或栈，而BFS则使用队列。

对于LeetCode 200岛屿数量问题，两种方法都能有效地识别和计数不同的岛屿，只是搜索策略不同。理解这两种算法的思想和实现方式，不仅有助于解决岛屿数量问题，也为解决其他图论问题奠定了基础。

在实际应用中，可以根据问题特点、数据规模和其他约束条件选择更合适的算法。通常，如果想要简洁的代码并且递归深度可控，可以选择DFS；如果担心栈溢出或需要找到最短路径，则可以选择BFS。