# Go 通道类型

通道（channel）是 Go 语言中用于 goroutine 之间通信的机制。

## 通道基础

- 通道是类型化的管道，只能传输特定类型的数据
- 通道是引用类型，需要使用 make 创建
- 通道的零值是 nil
- 通道支持并发安全的发送和接收操作

## 创建和使用通道

```go
package main

import "fmt"

func main() {
    // 创建无缓冲通道
    ch1 := make(chan int)
    
    // 创建有缓冲通道
    ch2 := make(chan string, 5)
    
    // 使用 var 声明
    var ch3 chan float64
    ch3 = make(chan float64)
    
    // 在 goroutine 中使用通道
    go func() {
        ch1 <- 42  // 发送数据
    }()
    
    value := <-ch1  // 接收数据
    fmt.Printf("接收到: %d\n", value)
    
    // 缓冲通道可以存储数据
    ch2 <- "Hello"
    ch2 <- "World"
    
    fmt.Printf("缓冲通道长度: %d, 容量: %d\n", len(ch2), cap(ch2))
    fmt.Printf("接收: %s\n", <-ch2)
    fmt.Printf("接收: %s\n", <-ch2)
    
    _ = ch3  // 避免未使用的变量警告
}
```

## 通道方向

```go
package main

import "fmt"

// 只发送通道
func send(ch chan<- int) {
    ch <- 100
}

// 只接收通道
func receive(ch <-chan int) {
    value := <-ch
    fmt.Printf("接收到: %d\n", value)
}

// 双向通道可以转换为单向通道
func main() {
    ch := make(chan int)
    
    go send(ch)
    receive(ch)
    
    // 通道方向示例
    ch2 := make(chan string, 1)
    
    // 作为只发送通道使用
    var sendOnly chan<- string = ch2
    sendOnly <- "Hello"
    
    // 作为只接收通道使用
    var recvOnly <-chan string = ch2
    msg := <-recvOnly
    fmt.Printf("消息: %s\n", msg)
}
```

## select 语句

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    // 启动两个 goroutine
    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "来自 ch1"
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "来自 ch2"
    }()
    
    // 使用 select 监听多个通道
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Println(msg1)
        case msg2 := <-ch2:
            fmt.Println(msg2)
        }
    }
    
    // 非阻塞 select
    ch3 := make(chan int, 1)
    select {
    case ch3 <- 10:
        fmt.Println("发送成功")
    default:
        fmt.Println("通道已满")
    }
    
    // 超时处理
    ch4 := make(chan string)
    select {
    case msg := <-ch4:
        fmt.Println(msg)
    case <-time.After(1 * time.Second):
        fmt.Println("超时")
    }
}
```

## 关闭通道

```go
package main

import "fmt"

func main() {
    // 关闭通道
    ch := make(chan int, 3)
    ch <- 1
    ch <- 2
    ch <- 3
    close(ch)
    
    // 从关闭的通道接收
    for i := 0; i < 5; i++ {
        if value, ok := <-ch; ok {
            fmt.Printf("接收到: %d\n", value)
        } else {
            fmt.Println("通道已关闭")
        }
    }
    
    // 使用 range 遍历通道
    ch2 := make(chan int)
    go func() {
        for i := 0; i < 5; i++ {
            ch2 <- i
        }
        close(ch2)
    }()
    
    fmt.Println("\n使用 range:")
    for value := range ch2 {
        fmt.Printf("值: %d\n", value)
    }
    
    // 检查通道是否关闭
    ch3 := make(chan string)
    close(ch3)
    
    _, ok := <-ch3
    if !ok {
        fmt.Println("\nch3 已关闭")
    }
}
```

## 通道模式

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 1. 扇出扇入模式
func fanOut(in <-chan int, out1, out2 chan<- int) {
    for value := range in {
        out1 <- value
        out2 <- value
    }
    close(out1)
    close(out2)
}

func fanIn(in1, in2 <-chan int, out chan<- int) {
    var wg sync.WaitGroup
    wg.Add(2)
    
    go func() {
        for value := range in1 {
            out <- value
        }
        wg.Done()
    }()
    
    go func() {
        for value := range in2 {
            out <- value
        }
        wg.Done()
    }()
    
    go func() {
        wg.Wait()
        close(out)
    }()
}

// 2. 工作池模式
func worker(id int, jobs <-chan int, results chan<- int) {
    for job := range jobs {
        fmt.Printf("工作者 %d 处理任务 %d\n", id, job)
        time.Sleep(time.Millisecond * 500)
        results <- job * 2
    }
}

func workerPool() {
    jobs := make(chan int, 100)
    results := make(chan int, 100)
    
    // 启动工作者
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }
    
    // 发送任务
    for j := 1; j <= 5; j++ {
        jobs <- j
    }
    close(jobs)
    
    // 收集结果
    for r := 1; r <= 5; r++ {
        result := <-results
        fmt.Printf("结果: %d\n", result)
    }
}

// 3. 管道模式
func generate(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}

func main() {
    fmt.Println("工作池模式:")
    workerPool()
    
    fmt.Println("\n管道模式:")
    // 管道：生成 -> 平方
    numbers := generate(2, 3, 4)
    squares := square(numbers)
    
    for result := range squares {
        fmt.Printf("平方: %d\n", result)
    }
}
```

## 通道同步

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 使用通道进行同步
func doWork(done chan bool) {
    fmt.Print("工作中...")
    time.Sleep(time.Second)
    fmt.Println("完成")
    
    done <- true
}

// 信号量模式
type Semaphore chan struct{}

func NewSemaphore(n int) Semaphore {
    return make(Semaphore, n)
}

func (s Semaphore) Acquire() {
    s <- struct{}{}
}

func (s Semaphore) Release() {
    <-s
}

func main() {
    // 同步等待
    done := make(chan bool, 1)
    go doWork(done)
    <-done
    
    // 使用 WaitGroup 和通道
    var wg sync.WaitGroup
    ch := make(chan int)
    
    // 生产者
    wg.Add(1)
    go func() {
        defer wg.Done()
        for i := 0; i < 5; i++ {
            ch <- i
        }
        close(ch)
    }()
    
    // 消费者
    go func() {
        for value := range ch {
            fmt.Printf("接收: %d\n", value)
        }
    }()
    
    wg.Wait()
    
    // 信号量示例
    fmt.Println("\n信号量示例:")
    sem := NewSemaphore(2)  // 最多2个并发
    
    for i := 0; i < 5; i++ {
        go func(id int) {
            sem.Acquire()
            defer sem.Release()
            
            fmt.Printf("任务 %d 开始\n", id)
            time.Sleep(time.Second)
            fmt.Printf("任务 %d 完成\n", id)
        }(i)
    }
    
    time.Sleep(3 * time.Second)
}
```

## 超时和取消

```go
package main

import (
    "context"
    "fmt"
    "time"
)

// 超时控制
func doLongTask() <-chan string {
    ch := make(chan string)
    go func() {
        time.Sleep(2 * time.Second)
        ch <- "任务完成"
    }()
    return ch
}

// 使用 context 取消
func doTaskWithContext(ctx context.Context) <-chan string {
    ch := make(chan string)
    go func() {
        select {
        case <-time.After(3 * time.Second):
            ch <- "任务完成"
        case <-ctx.Done():
            ch <- "任务被取消"
        }
    }()
    return ch
}

func main() {
    // 超时示例
    fmt.Println("超时示例:")
    select {
    case result := <-doLongTask():
        fmt.Println(result)
    case <-time.After(1 * time.Second):
        fmt.Println("操作超时")
    }
    
    // Context 取消示例
    fmt.Println("\nContext 取消示例:")
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()
    
    result := <-doTaskWithContext(ctx)
    fmt.Println(result)
    
    // 心跳检测
    fmt.Println("\n心跳检测:")
    heartbeat := time.NewTicker(500 * time.Millisecond)
    defer heartbeat.Stop()
    
    timeout := time.After(2 * time.Second)
    
    for {
        select {
        case <-heartbeat.C:
            fmt.Println("心跳")
        case <-timeout:
            fmt.Println("超时退出")
            return
        }
    }
}
```

## 通道的陷阱和最佳实践

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 1. 向 nil 通道发送或接收会永久阻塞
    var nilCh chan int
    go func() {
        // nilCh <- 1  // 永久阻塞
        // <-nilCh     // 永久阻塞
    }()
    
    // 2. 向已关闭的通道发送会 panic
    closedCh := make(chan int)
    close(closedCh)
    // closedCh <- 1  // panic
    
    // 3. 重复关闭通道会 panic
    ch := make(chan int)
    close(ch)
    // close(ch)  // panic
    
    // 4. 通道泄漏
    // 避免创建没有接收者的发送操作
    leakyCh := make(chan int)
    go func() {
        // 如果没有接收者，这个 goroutine 会泄漏
        select {
        case leakyCh <- 1:
            fmt.Println("发送成功")
        case <-time.After(1 * time.Second):
            fmt.Println("发送超时，避免泄漏")
        }
    }()
    
    time.Sleep(2 * time.Second)
    
    fmt.Println("避免了通道相关的陷阱")
}

// 最佳实践示例
type Result struct {
    Value int
    Err   error
}

func processWithTimeout(data int, timeout time.Duration) (int, error) {
    resultCh := make(chan Result, 1)
    
    go func() {
        // 模拟处理
        time.Sleep(100 * time.Millisecond)
        resultCh <- Result{Value: data * 2, Err: nil}
    }()
    
    select {
    case result := <-resultCh:
        return result.Value, result.Err
    case <-time.After(timeout):
        return 0, fmt.Errorf("处理超时")
    }
}
```

## 性能考虑

1. **缓冲区大小**：合理设置缓冲区大小，避免过大或过小
2. **避免过度使用通道**：简单的共享内存访问可能更高效
3. **批量处理**：发送数据切片而不是单个元素
4. **重用通道**：避免频繁创建和销毁通道
5. **选择合适的同步原语**：有时 sync 包的原语更合适

## 通道 vs 其他同步机制

| 特性 | 通道 | sync.Mutex | sync.WaitGroup |
|------|------|------------|----------------|
| 用途 | 通信和同步 | 互斥访问 | 等待多个操作 |
| 性能 | 中等 | 高 | 高 |
| 复杂度 | 中等 | 低 | 低 |
| 适用场景 | goroutine 通信 | 保护共享资源 | 等待并发任务 |