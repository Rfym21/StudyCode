# Go 函数类型

在 Go 中，函数是一等公民（first-class citizens），可以作为变量、参数和返回值。

## 函数类型基础

```go
package main

import "fmt"

// 函数声明
func add(a, b int) int {
    return a + b
}

// 多返回值
func divmod(a, b int) (int, int) {
    return a / b, a % b
}

// 命名返回值
func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return  // 裸返回
}

// 可变参数
func sum(nums ...int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}

func main() {
    // 调用函数
    result := add(3, 4)
    fmt.Printf("3 + 4 = %d\n", result)

    // 多返回值
    q, r := divmod(10, 3)
    fmt.Printf("10 ÷ 3 = %d 余 %d\n", q, r)

    // 命名返回值
    x, y := split(17)
    fmt.Printf("split(17) = %d, %d\n", x, y)

    // 可变参数
    fmt.Printf("sum(1,2,3,4,5) = %d\n", sum(1, 2, 3, 4, 5))

    // 展开切片作为参数
    numbers := []int{1, 2, 3, 4, 5}
    fmt.Printf("sum(slice...) = %d\n", sum(numbers...))
}
```

**输出结果：**
```
3 + 4 = 7
10 ÷ 3 = 3 余 1
split(17) = 7, 10
sum(1,2,3,4,5) = 15
sum(slice...) = 15
```

## 函数作为类型

```go
package main

import "fmt"

// 定义函数类型
type Operation func(int, int) int

// 函数作为参数
func calculate(a, b int, op Operation) int {
    return op(a, b)
}

// 函数作为返回值
func getOperation(opType string) Operation {
    switch opType {
    case "add":
        return func(a, b int) int { return a + b }
    case "multiply":
        return func(a, b int) int { return a * b }
    default:
        return func(a, b int) int { return 0 }
    }
}

func main() {
    // 函数变量
    var fn func(int, int) int
    fn = func(a, b int) int {
        return a + b
    }
    fmt.Printf("fn(3, 4) = %d\n", fn(3, 4))

    // 使用函数类型
    add := func(a, b int) int { return a + b }
    multiply := func(a, b int) int { return a * b }

    fmt.Printf("calculate(5, 3, add) = %d\n", calculate(5, 3, add))
    fmt.Printf("calculate(5, 3, multiply) = %d\n", calculate(5, 3, multiply))

    // 获取函数
    op := getOperation("add")
    fmt.Printf("op(10, 20) = %d\n", op(10, 20))
}
```

**输出结果：**
```
fn(3, 4) = 7
calculate(5, 3, add) = 8
calculate(5, 3, multiply) = 15
op(10, 20) = 30
```

## 匿名函数和闭包

```go
package main

import "fmt"

// 返回闭包
func counter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

// 闭包作为参数
func apply(nums []int, fn func(int) int) []int {
    result := make([]int, len(nums))
    for i, n := range nums {
        result[i] = fn(n)
    }
    return result
}

func main() {
    // 匿名函数
    func() {
        fmt.Println("匿名函数立即执行")
    }()

    // 赋值给变量
    greet := func(name string) {
        fmt.Printf("Hello, %s!\n", name)
    }
    greet("World")

    // 闭包
    c1 := counter()
    c2 := counter()

    fmt.Printf("c1: %d, %d, %d\n", c1(), c1(), c1())
    fmt.Printf("c2: %d, %d\n", c2(), c2())

    // 闭包修改外部变量
    x := 10
    add := func(y int) int {
        x += y  // 修改外部变量
        return x
    }
    fmt.Printf("add(5) = %d\n", add(5))
    fmt.Printf("x = %d\n", x)

    // 使用闭包处理切片
    numbers := []int{1, 2, 3, 4, 5}
    doubled := apply(numbers, func(n int) int { return n * 2 })
    fmt.Printf("doubled: %v\n", doubled)
}
```

**输出结果：**
```
匿名函数立即执行
Hello, World!
c1: 1, 2, 3
c2: 1, 2
add(5) = 15
x = 15
doubled: [2 4 6 8 10]
```

## 高阶函数

```go
package main

import (
    "fmt"
    "sort"
    "strings"
)

// 函数组合
func compose(f, g func(int) int) func(int) int {
    return func(x int) int {
        return f(g(x))
    }
}

// 柯里化
func add(a int) func(int) int {
    return func(b int) int {
        return a + b
    }
}

// 过滤函数
func filter(slice []int, predicate func(int) bool) []int {
    result := []int{}
    for _, v := range slice {
        if predicate(v) {
            result = append(result, v)
        }
    }
    return result
}

// Map 函数
func mapInts(slice []int, fn func(int) int) []int {
    result := make([]int, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}

// Reduce 函数
func reduce(slice []int, initial int, fn func(int, int) int) int {
    result := initial
    for _, v := range slice {
        result = fn(result, v)
    }
    return result
}

func main() {
    // 函数组合
    double := func(x int) int { return x * 2 }
    addOne := func(x int) int { return x + 1 }
    doubleThenAddOne := compose(addOne, double)

    fmt.Printf("compose(addOne, double)(5) = %d\n", doubleThenAddOne(5))

    // 柯里化
    add5 := add(5)
    fmt.Printf("add5(3) = %d\n", add5(3))

    // 高阶函数使用
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

    evens := filter(numbers, func(n int) bool { return n%2 == 0 })
    fmt.Printf("偶数: %v\n", evens)

    squared := mapInts(numbers, func(n int) int { return n * n })
    fmt.Printf("平方: %v\n", squared)

    sum := reduce(numbers, 0, func(a, b int) int { return a + b })
    fmt.Printf("总和: %d\n", sum)

    // 排序时使用函数
    people := []string{"Alice", "bob", "Charlie", "david"}
    sort.Slice(people, func(i, j int) bool {
        return strings.ToLower(people[i]) < strings.ToLower(people[j])
    })
    fmt.Printf("排序后: %v\n", people)
}
```

**输出结果：**
```
compose(addOne, double)(5) = 11
add5(3) = 8
偶数: [2 4 6 8 10]
平方: [1 4 9 16 25 36 49 64 81 100]
总和: 55
排序后: [Alice bob Charlie david]
```

## defer 语句

```go
package main

import (
    "fmt"
    "os"
)

func fileOperation() error {
    file, err := os.Create("test.txt")
    if err != nil {
        return err
    }
    defer file.Close()  // 确保文件关闭
    
    // 文件操作...
    _, err = file.WriteString("Hello, World!")
    return err
}

func deferOrder() {
    defer fmt.Println("第一个 defer")
    defer fmt.Println("第二个 defer")
    defer fmt.Println("第三个 defer")
    fmt.Println("函数体")
}

func deferWithLoop() {
    for i := 0; i < 3; i++ {
        defer fmt.Printf("defer %d\n", i)
    }
    fmt.Println("循环结束")
}

func main() {
    // defer 执行顺序（LIFO）
    deferOrder()

    fmt.Println("\n循环中的 defer:")
    deferWithLoop()

    // defer 与返回值
    fmt.Printf("\ndefer 与返回值: %d\n", deferReturn())

    // 文件操作示例
    if err := fileOperation(); err != nil {
        fmt.Printf("文件操作错误: %v\n", err)
    }

    // 清理文件
    os.Remove("test.txt")
}
```

**输出结果：**
```
函数体
第三个 defer
第二个 defer
第一个 defer

循环中的 defer:
循环结束
defer 2
defer 1
defer 0

defer 与返回值: 11

func deferReturn() (result int) {
    defer func() {
        result++  // 可以修改命名返回值
    }()
    return 10
}
```

## 方法作为函数

```go
package main

import "fmt"

type Calculator struct {
    value float64
}

func (c *Calculator) Add(x float64) {
    c.value += x
}

func (c *Calculator) Multiply(x float64) {
    c.value *= x
}

func (c Calculator) GetValue() float64 {
    return c.value
}

func main() {
    calc := &Calculator{value: 10}

    // 方法值
    addMethod := calc.Add
    addMethod(5)
    fmt.Printf("加 5 后: %.2f\n", calc.GetValue())

    // 方法表达式
    multiplyMethod := (*Calculator).Multiply
    multiplyMethod(calc, 2)
    fmt.Printf("乘 2 后: %.2f\n", calc.GetValue())

    // 将方法作为函数传递
    operations := []func(float64){
        calc.Add,
        calc.Multiply,
    }

    for _, op := range operations {
        op(3)
    }
    fmt.Printf("执行操作后: %.2f\n", calc.GetValue())
}
```

**输出结果：**
```
加 5 后: 15.00
乘 2 后: 30.00
执行操作后: 99.00
```

## 函数选项模式

```go
package main

import "fmt"

// 配置结构体
type ServerConfig struct {
    Host    string
    Port    int
    Timeout int
    Debug   bool
}

// 选项函数类型
type ServerOption func(*ServerConfig)

// 选项函数
func WithHost(host string) ServerOption {
    return func(cfg *ServerConfig) {
        cfg.Host = host
    }
}

func WithPort(port int) ServerOption {
    return func(cfg *ServerConfig) {
        cfg.Port = port
    }
}

func WithTimeout(timeout int) ServerOption {
    return func(cfg *ServerConfig) {
        cfg.Timeout = timeout
    }
}

func WithDebug(debug bool) ServerOption {
    return func(cfg *ServerConfig) {
        cfg.Debug = debug
    }
}

// 使用选项模式的构造函数
func NewServer(options ...ServerOption) *ServerConfig {
    // 默认配置
    cfg := &ServerConfig{
        Host:    "localhost",
        Port:    8080,
        Timeout: 30,
        Debug:   false,
    }
    
    // 应用选项
    for _, option := range options {
        option(cfg)
    }
    
    return cfg
}

func main() {
    // 使用默认配置
    server1 := NewServer()
    fmt.Printf("默认配置: %+v\n", server1)

    // 自定义配置
    server2 := NewServer(
        WithHost("192.168.1.100"),
        WithPort(9000),
        WithDebug(true),
    )
    fmt.Printf("自定义配置: %+v\n", server2)
}
```

**输出结果：**
```
默认配置: &{Host:localhost Port:8080 Timeout:30 Debug:false}
自定义配置: &{Host:192.168.1.100 Port:9000 Timeout:30 Debug:true}
```

## 错误处理函数

```go
package main

import (
    "errors"
    "fmt"
)

// 错误处理函数类型
type ErrorHandler func(error)

// 带错误处理的执行器
func tryExecute(fn func() error, handler ErrorHandler) {
    if err := fn(); err != nil {
        handler(err)
    }
}

// 重试函数
func retry(attempts int, fn func() error) error {
    for i := 0; i < attempts; i++ {
        if err := fn(); err == nil {
            return nil
        } else if i == attempts-1 {
            return err
        }
        fmt.Printf("尝试 %d 失败，重试中...\n", i+1)
    }
    return errors.New("所有尝试都失败了")
}

func main() {
    // 使用错误处理器
    tryExecute(
        func() error {
            return errors.New("模拟错误")
        },
        func(err error) {
            fmt.Printf("错误处理: %v\n", err)
        },
    )

    // 重试机制
    count := 0
    err := retry(3, func() error {
        count++
        if count < 3 {
            return errors.New("还没成功")
        }
        fmt.Println("成功了！")
        return nil
    })

    if err != nil {
        fmt.Printf("最终失败: %v\n", err)
    }
}
```

**输出结果：**
```
错误处理: 模拟错误
尝试 1 失败，重试中...
尝试 2 失败，重试中...
成功了！
```

## 性能建议

1. **避免过度使用闭包**：闭包会捕获变量，可能导致内存泄漏
2. **内联小函数**：编译器会自动内联小函数
3. **预分配切片**：在高阶函数中预分配结果切片
4. **避免接口开销**：直接函数调用比接口方法调用更快
5. **defer 的开销**：defer 有一定开销，在性能敏感的场景中谨慎使用