# Go 零值

在 Go 中，变量声明后如果没有显式初始化，会自动获得该类型的零值。

## 基本类型的零值

```go
package main

import "fmt"

func main() {
    // 数值类型的零值是 0
    var i int
    var i8 int8
    var i16 int16
    var i32 int32
    var i64 int64
    fmt.Printf("整数零值: int=%d, int8=%d, int16=%d, int32=%d, int64=%d\n", 
        i, i8, i16, i32, i64)
    
    var u uint
    var u8 uint8
    var u16 uint16
    var u32 uint32
    var u64 uint64
    fmt.Printf("无符号整数零值: uint=%d, uint8=%d, uint16=%d, uint32=%d, uint64=%d\n", 
        u, u8, u16, u32, u64)
    
    // 浮点数的零值是 0.0
    var f32 float32
    var f64 float64
    fmt.Printf("浮点数零值: float32=%f, float64=%f\n", f32, f64)
    
    // 复数的零值是 0+0i
    var c64 complex64
    var c128 complex128
    fmt.Printf("复数零值: complex64=%v, complex128=%v\n", c64, c128)
    
    // 布尔值的零值是 false
    var b bool
    fmt.Printf("布尔零值: %t\n", b)
    
    // 字符串的零值是空字符串 ""
    var s string
    fmt.Printf("字符串零值: '%s' (长度: %d)\n", s, len(s))
    
    // byte 和 rune 的零值
    var bt byte  // uint8 的别名
    var r rune   // int32 的别名
    fmt.Printf("byte 零值: %d, rune 零值: %d\n", bt, r)
}
```

## 复合类型的零值

```go
package main

import "fmt"

func main() {
    // 指针的零值是 nil
    var p *int
    fmt.Printf("指针零值: %v (是否为nil: %t)\n", p, p == nil)
    
    // 切片的零值是 nil
    var slice []int
    fmt.Printf("切片零值: %v (是否为nil: %t, len=%d, cap=%d)\n", 
        slice, slice == nil, len(slice), cap(slice))
    
    // 映射的零值是 nil
    var m map[string]int
    fmt.Printf("映射零值: %v (是否为nil: %t)\n", m, m == nil)
    
    // 通道的零值是 nil
    var ch chan int
    fmt.Printf("通道零值: %v (是否为nil: %t)\n", ch, ch == nil)
    
    // 函数的零值是 nil
    var fn func()
    fmt.Printf("函数零值: %v (是否为nil: %t)\n", fn, fn == nil)
    
    // 接口的零值是 nil
    var i interface{}
    fmt.Printf("接口零值: %v (是否为nil: %t)\n", i, i == nil)
    
    // 数组的零值是所有元素都是零值
    var arr [3]int
    fmt.Printf("数组零值: %v\n", arr)
    
    var strArr [3]string
    fmt.Printf("字符串数组零值: %v\n", strArr)
}
```

## 结构体的零值

```go
package main

import "fmt"

type Person struct {
    Name    string
    Age     int
    Height  float64
    Married bool
    Address *Address
    Hobbies []string
    Scores  map[string]int
}

type Address struct {
    Street string
    City   string
    ZipCode string
}

func main() {
    // 结构体的零值是所有字段都是零值
    var p Person
    fmt.Printf("Person 零值:\n")
    fmt.Printf("  Name: '%s'\n", p.Name)
    fmt.Printf("  Age: %d\n", p.Age)
    fmt.Printf("  Height: %f\n", p.Height)
    fmt.Printf("  Married: %t\n", p.Married)
    fmt.Printf("  Address: %v\n", p.Address)
    fmt.Printf("  Hobbies: %v (nil: %t)\n", p.Hobbies, p.Hobbies == nil)
    fmt.Printf("  Scores: %v (nil: %t)\n", p.Scores, p.Scores == nil)
    
    // 嵌套结构体
    var addr Address
    fmt.Printf("\nAddress 零值: %+v\n", addr)
    
    // 使用零值结构体
    if p.Address == nil {
        fmt.Println("\nAddress 是 nil，需要初始化")
    }
    
    // 零值可用性
    fmt.Printf("\n零值 Person 的名字长度: %d\n", len(p.Name))
    // 注意：不能向 nil map 添加元素
    // p.Scores["math"] = 100  // panic
}
```

## 零值的实用性

```go
package main

import (
    "bytes"
    "fmt"
    "sync"
)

// 1. sync.Mutex 的零值是未锁定的互斥锁
type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

// 2. bytes.Buffer 的零值是空的缓冲区
func useBuffer() {
    var buf bytes.Buffer  // 零值可用
    buf.WriteString("Hello")
    buf.WriteString(" ")
    buf.WriteString("World")
    fmt.Printf("Buffer: %s\n", buf.String())
}

// 3. 零值切片可以直接使用
func useSlice() {
    var nums []int  // nil 切片
    nums = append(nums, 1, 2, 3)  // 可以直接 append
    fmt.Printf("切片: %v\n", nums)
}

func main() {
    // 使用零值 Counter
    var counter Counter  // 零值可用
    counter.Increment()
    counter.Increment()
    fmt.Printf("计数器: %d\n", counter.Value())
    
    // 使用零值 Buffer
    useBuffer()
    
    // 使用零值切片
    useSlice()
    
    // 零值的 bool 在条件判断中很有用
    type Config struct {
        Debug   bool
        Verbose bool
    }
    
    var cfg Config  // 默认都是 false
    if !cfg.Debug {
        fmt.Println("Debug 模式关闭（默认）")
    }
}
```

## 零值与初始化

```go
package main

import "fmt"

// 利用零值设计 API
type Server struct {
    Host string
    Port int
}

func (s *Server) Address() string {
    host := s.Host
    if host == "" {  // 利用零值
        host = "localhost"
    }
    
    port := s.Port
    if port == 0 {  // 利用零值
        port = 8080
    }
    
    return fmt.Sprintf("%s:%d", host, port)
}

// 零值作为有效值
type Optional struct {
    Value int
    Valid bool  // false 表示没有值
}

func main() {
    // 使用零值作为默认值
    var s1 Server
    fmt.Printf("默认地址: %s\n", s1.Address())
    
    s2 := Server{Port: 9000}
    fmt.Printf("自定义端口: %s\n", s2.Address())
    
    // Optional 模式
    var opt Optional
    if !opt.Valid {
        fmt.Println("没有值")
    }
    
    opt2 := Optional{Value: 0, Valid: true}
    if opt2.Valid {
        fmt.Printf("有值: %d\n", opt2.Value)
    }
}
```

## 检查零值

```go
package main

import (
    "fmt"
    "reflect"
)

// 使用反射检查零值
func isZero(v interface{}) bool {
    return reflect.DeepEqual(v, reflect.Zero(reflect.TypeOf(v)).Interface())
}

// 手动检查常见类型的零值
func checkZeroValues() {
    // 字符串
    var s string
    if s == "" {
        fmt.Println("字符串是零值")
    }
    
    // 数字
    var i int
    if i == 0 {
        fmt.Println("整数是零值")
    }
    
    // 指针、切片、映射、通道、函数、接口
    var (
        p  *int
        sl []int
        m  map[string]int
        ch chan int
        fn func()
        in interface{}
    )
    
    if p == nil && sl == nil && m == nil && ch == nil && fn == nil && in == nil {
        fmt.Println("所有引用类型都是 nil")
    }
}

func main() {
    // 使用反射检查
    fmt.Println("使用反射检查零值:")
    fmt.Printf("0 是零值: %t\n", isZero(0))
    fmt.Printf("\"\" 是零值: %t\n", isZero(""))
    fmt.Printf("false 是零值: %t\n", isZero(false))
    fmt.Printf("nil 是零值: %t\n", isZero((*int)(nil)))
    
    fmt.Println("\n手动检查:")
    checkZeroValues()
    
    // 结构体零值检查
    type Person struct {
        Name string
        Age  int
    }
    
    var p Person
    if p == (Person{}) {
        fmt.Println("Person 是零值")
    }
}
```

## 零值的注意事项

```go
package main

import "fmt"

func main() {
    // 1. nil map 不能写入
    var m map[string]int
    // m["key"] = 1  // panic: assignment to entry in nil map
    
    // 但可以读取（返回零值）
    value := m["key"]
    fmt.Printf("从 nil map 读取: %d\n", value)
    
    // 2. nil 切片可以 append
    var s []int
    s = append(s, 1, 2, 3)  // 正常工作
    fmt.Printf("append 到 nil 切片: %v\n", s)
    
    // 3. nil 指针解引用会 panic
    var p *int
    // fmt.Println(*p)  // panic: runtime error: invalid memory address
    
    // 4. nil 接口的特殊情况
    var i interface{}
    var p2 *int
    i = p2
    
    fmt.Printf("i == nil: %t\n", i == nil)  // false！
    fmt.Printf("i.(*int) == nil: %t\n", i.(*int) == nil)  // true
    
    // 5. 零值的方法调用
    type MyStruct struct {
        value int
    }
    
    func (m *MyStruct) IsZero() bool {
        return m == nil || m.value == 0
    }
    
    var ms *MyStruct
    fmt.Printf("nil 接收者调用方法: %t\n", ms.IsZero())  // 不会 panic
}
```

## 最佳实践

1. **利用零值**：设计 API 时考虑零值的可用性
2. **明确初始化**：需要非零值时显式初始化
3. **检查 nil**：使用指针、切片、映射等之前检查是否为 nil
4. **文档说明**：说明类型的零值行为
5. **零值友好**：让类型的零值尽可能有用

```go
package main

import "fmt"

// 好的设计：零值可用
type Logger struct {
    prefix string
}

func (l *Logger) Log(msg string) {
    if l.prefix == "" {
        fmt.Println(msg)
    } else {
        fmt.Printf("[%s] %s\n", l.prefix, msg)
    }
}

func main() {
    // 零值可以直接使用
    var logger Logger
    logger.Log("这是一条日志")
    
    // 也可以自定义
    logger2 := Logger{prefix: "INFO"}
    logger2.Log("这是另一条日志")
}