# Go 数组类型

数组是具有固定长度的相同类型元素的序列。

## 数组基础

- 固定长度：数组的长度是类型的一部分
- 值类型：数组是值类型，赋值和传参会复制整个数组
- 内存连续：数组元素在内存中连续存储

## 声明和初始化

```go
package main

import "fmt"

func main() {
    // 声明数组
    var arr1 [5]int                    // 零值数组 [0 0 0 0 0]
    var arr2 = [5]int{1, 2, 3, 4, 5}  // 完整初始化
    var arr3 = [...]int{1, 2, 3}      // 自动推断长度
    var arr4 = [5]int{1, 3: 10}       // 部分初始化，索引3为10

    fmt.Printf("arr1: %v\n", arr1)
    fmt.Printf("arr2: %v\n", arr2)
    fmt.Printf("arr3: %v\n", arr3)
    fmt.Printf("arr4: %v\n", arr4)
    
    // 使用索引初始化
    arr5 := [5]string{0: "Go", 2: "Python", 4: "Java"}
    fmt.Printf("arr5: %v\n", arr5)
}
```

## 访问和修改元素

```go
package main

import "fmt"

func main() {
    arr := [5]int{10, 20, 30, 40, 50}
    
    // 访问元素
    fmt.Printf("第一个元素: %d\n", arr[0])
    fmt.Printf("最后一个元素: %d\n", arr[len(arr)-1])
    
    // 修改元素
    arr[0] = 100
    arr[len(arr)-1] = 500
    fmt.Printf("修改后: %v\n", arr)
    
    // 数组长度
    fmt.Printf("数组长度: %d\n", len(arr))
    
    // 数组容量（与长度相同）
    fmt.Printf("数组容量: %d\n", cap(arr))
}
```

## 遍历数组

```go
package main

import "fmt"

func main() {
    arr := [5]string{"Go", "Python", "Java", "C++", "Rust"}
    
    // 使用 for 循环遍历
    fmt.Println("使用索引遍历:")
    for i := 0; i < len(arr); i++ {
        fmt.Printf("%d: %s\n", i, arr[i])
    }
    
    // 使用 range 遍历
    fmt.Println("\n使用 range 遍历:")
    for index, value := range arr {
        fmt.Printf("%d: %s\n", index, value)
    }
    
    // 只需要值，忽略索引
    fmt.Println("\n只遍历值:")
    for _, value := range arr {
        fmt.Println(value)
    }
    
    // 只需要索引
    fmt.Println("\n只遍历索引:")
    for index := range arr {
        fmt.Println(index)
    }
}
```

## 多维数组

```go
package main

import "fmt"

func main() {
    // 二维数组
    var matrix [3][3]int
    
    // 初始化二维数组
    matrix2 := [3][3]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }
    
    // 访问和修改
    matrix[1][1] = 5
    fmt.Printf("matrix: %v\n", matrix)
    fmt.Printf("matrix2: %v\n", matrix2)
    
    // 遍历二维数组
    fmt.Println("\n遍历二维数组:")
    for i := 0; i < len(matrix2); i++ {
        for j := 0; j < len(matrix2[i]); j++ {
            fmt.Printf("%d ", matrix2[i][j])
        }
        fmt.Println()
    }
    
    // 三维数组
    var cube [2][3][4]int
    fmt.Printf("\n三维数组大小: %d x %d x %d\n", 
        len(cube), len(cube[0]), len(cube[0][0]))
}
```

## 数组作为函数参数

```go
package main

import "fmt"

// 数组作为参数（值传递）
func modifyArray(arr [5]int) {
    arr[0] = 999  // 修改副本，不影响原数组
}

// 使用指针传递数组
func modifyArrayByPointer(arr *[5]int) {
    arr[0] = 999  // 修改原数组
}

// 使用切片更灵活
func modifySlice(arr []int) {
    if len(arr) > 0 {
        arr[0] = 999
    }
}

func main() {
    arr := [5]int{1, 2, 3, 4, 5}
    
    // 值传递
    modifyArray(arr)
    fmt.Printf("值传递后: %v\n", arr)  // 不变
    
    // 指针传递
    modifyArrayByPointer(&arr)
    fmt.Printf("指针传递后: %v\n", arr)  // 改变
    
    // 转换为切片
    modifySlice(arr[:])
    fmt.Printf("切片传递后: %v\n", arr)  // 改变
}
```

## 数组比较

```go
package main

import "fmt"

func main() {
    arr1 := [3]int{1, 2, 3}
    arr2 := [3]int{1, 2, 3}
    arr3 := [3]int{1, 2, 4}
    arr4 := [4]int{1, 2, 3, 4}
    
    // 相同类型的数组可以比较
    fmt.Printf("arr1 == arr2: %t\n", arr1 == arr2)  // true
    fmt.Printf("arr1 == arr3: %t\n", arr1 == arr3)  // false
    
    // 不同长度的数组是不同类型，不能比较
    // fmt.Printf("arr1 == arr4: %t\n", arr1 == arr4)  // 编译错误
    _ = arr4  // 避免未使用的变量警告
}
```

## 数组的应用场景

```go
package main

import "fmt"

// 1. 固定大小的缓冲区
type Buffer [1024]byte

// 2. 矩阵运算
func addMatrices(a, b [3][3]int) [3][3]int {
    var result [3][3]int
    for i := 0; i < 3; i++ {
        for j := 0; j < 3; j++ {
            result[i][j] = a[i][j] + b[i][j]
        }
    }
    return result
}

// 3. 哈希表的桶
type HashTable struct {
    buckets [256][]string  // 256个桶的哈希表
}

func main() {
    // 示例：矩阵加法
    matrix1 := [3][3]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}
    matrix2 := [3][3]int{{9, 8, 7}, {6, 5, 4}, {3, 2, 1}}
    
    result := addMatrices(matrix1, matrix2)
    fmt.Println("矩阵相加结果:")
    for _, row := range result {
        fmt.Println(row)
    }
}
```

## 数组 vs 切片

| 特性 | 数组 | 切片 |
|------|------|------|
| 长度 | 固定 | 动态 |
| 类型 | 值类型 | 引用类型 |
| 传递 | 复制整个数组 | 传递引用 |
| 比较 | 可以用 == 比较 | 不能直接比较 |
| 零值 | 元素的零值 | nil |
| 使用场景 | 固定大小的数据 | 动态数据集合 |

## 注意事项

1. **数组长度是类型的一部分**：`[5]int` 和 `[10]int` 是不同的类型
2. **值传递**：数组赋值和传参会复制整个数组，大数组可能影响性能
3. **使用切片**：在大多数情况下，切片比数组更灵活和常用
4. **边界检查**：Go 会在运行时检查数组访问是否越界