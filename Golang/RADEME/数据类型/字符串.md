# Go 字符串类型

字符串是 Go 中的基本数据类型之一，是不可变的字节序列。

## 字符串基础

- 类型名：`string`
- 编码：UTF-8
- 特性：不可变（immutable）
- 零值：`""` (空字符串)

## 创建字符串

```go
package main

import "fmt"

func main() {
    // 使用双引号创建
    var str1 string = "Hello, World!"
    var str2 string = "你好，世界！"
    
    // 零值
    var emptyStr string  // 零值是空字符串 ""
    
    // 原始字符串字面量（使用反引号）
    var rawStr string = `这是一个
多行字符串
包含换行符`
    
    fmt.Printf("str1: %s\n", str1)
    fmt.Printf("str2: %s\n", str2)
    fmt.Printf("emptyStr: '%s'\n", emptyStr)
    fmt.Printf("rawStr:\n%s\n", rawStr)
}
```

**输出结果：**
```
str1: Hello, World!
str2: 你好，世界！
emptyStr: ''
rawStr:
这是一个
多行字符串
包含换行符
```

## 字符串操作

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    str := "Hello, Go!"
    
    // 长度（字节数）
    fmt.Printf("字节长度: %d\n", len(str))
    
    // 字符串拼接
    str1 := "Hello"
    str2 := "World"
    combined := str1 + ", " + str2 + "!"
    fmt.Printf("拼接结果: %s\n", combined)
    
    // 使用 strings 包的函数
    fmt.Printf("是否包含 'Go': %t\n", strings.Contains(str, "Go"))
    fmt.Printf("是否以 'Hello' 开头: %t\n", strings.HasPrefix(str, "Hello"))
    fmt.Printf("是否以 '!' 结尾: %t\n", strings.HasSuffix(str, "!"))
    fmt.Printf("'o' 的位置: %d\n", strings.Index(str, "o"))
    fmt.Printf("替换: %s\n", strings.Replace(str, "Go", "Golang", 1))
    fmt.Printf("转大写: %s\n", strings.ToUpper(str))
    fmt.Printf("转小写: %s\n", strings.ToLower(str))
    
    // 分割和连接
    parts := strings.Split("a,b,c", ",")
    fmt.Printf("分割结果: %v\n", parts)
    joined := strings.Join(parts, "-")
    fmt.Printf("连接结果: %s\n", joined)
}
```

**输出结果：**
```
字节长度: 10
拼接结果: Hello, World!
是否包含 'Go': true
是否以 'Hello' 开头: true
是否以 '!' 结尾: true
'o' 的位置: 4
替换: Hello, Golang!
转大写: HELLO, GO!
转小写: hello, go!
分割结果: [a b c]
连接结果: a-b-c
```

## 字符串与字符

```go
package main

import "fmt"

func main() {
    str := "Hello, 世界"
    
    // 访问单个字节
    fmt.Printf("第一个字节: %d (%c)\n", str[0], str[0])
    
    // 遍历字节
    fmt.Println("遍历字节:")
    for i := 0; i < len(str); i++ {
        fmt.Printf("%d: %d\n", i, str[i])
    }
    
    // 遍历字符（rune）
    fmt.Println("\n遍历字符:")
    for i, ch := range str {
        fmt.Printf("%d: %c (U+%04X)\n", i, ch, ch)
    }
    
    // 字符串转 rune 切片
    runes := []rune(str)
    fmt.Printf("\nrune 切片长度: %d\n", len(runes))
    fmt.Printf("第 7 个字符: %c\n", runes[7])
}
```

**输出结果：**
```
第一个字节: 72 (H)
遍历字节:
0: 72
1: 101
2: 108
3: 108
4: 111
5: 44
6: 32
7: 228
8: 184
9: 150
10: 231
11: 149
12: 140

遍历字符:
0: H (U+0048)
1: e (U+0065)
2: l (U+006C)
3: l (U+006C)
4: o (U+006F)
5: , (U+002C)
6:   (U+0020)
7: 世 (U+4E16)
10: 界 (U+754C)

rune 切片长度: 9
第 7 个字符: 世
```

## 字符串不可变性

```go
package main

import "fmt"

func main() {
    str := "Hello"
    
    // 下面的操作会导致编译错误
    // str[0] = 'h'  // 错误：cannot assign to str[0]
    
    // 要修改字符串，需要转换为 []byte 或 []rune
    bytes := []byte(str)
    bytes[0] = 'h'
    newStr := string(bytes)
    fmt.Printf("原字符串: %s\n", str)
    fmt.Printf("新字符串: %s\n", newStr)
    
    // 或者使用 rune 处理 Unicode
    runes := []rune("你好")
    runes[0] = '您'
    fmt.Printf("修改后: %s\n", string(runes))
}
```

**输出结果：**
```
原字符串: Hello
新字符串: hello
修改后: 您好
```

## 字符串与字节切片转换

```go
package main

import "fmt"

func main() {
    // string 转 []byte
    str := "Hello, Go!"
    bytes := []byte(str)
    fmt.Printf("字节切片: %v\n", bytes)
    
    // []byte 转 string
    newStr := string(bytes)
    fmt.Printf("字符串: %s\n", newStr)
    
    // 注意：转换会复制数据
    bytes[0] = 'h'
    fmt.Printf("修改 bytes 后，原字符串: %s\n", str)  // 不变
    fmt.Printf("修改 bytes 后，bytes: %s\n", string(bytes))
}
```

**输出结果：**
```
字节切片: [72 101 108 108 111 44 32 71 111 33]
字符串: Hello, Go!
修改 bytes 后，原字符串: Hello, Go!
修改 bytes 后，bytes: hello, Go!
```

## 字符串比较

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    str1 := "Hello"
    str2 := "Hello"
    str3 := "hello"
    
    // 直接比较（区分大小写）
    fmt.Printf("str1 == str2: %t\n", str1 == str2)
    fmt.Printf("str1 == str3: %t\n", str1 == str3)
    
    // 忽略大小写比较
    fmt.Printf("忽略大小写比较: %t\n", 
        strings.EqualFold(str1, str3))
    
    // 字典序比较
    fmt.Printf("str1 < str3: %t\n", str1 < str3)
    fmt.Printf("Compare 结果: %d\n",
        strings.Compare(str1, str3))
}
```

**输出结果：**
```
str1 == str2: true
str1 == str3: false
忽略大小写比较: true
str1 < str3: true
Compare 结果: -1
```

## 多行字符串

```go
package main

import "fmt"

func main() {
    // 使用反引号的原始字符串
    multiline := `第一行
第二行
    带缩进的第三行
特殊字符不转义: \n \t`
    
    fmt.Println(multiline)
    
    // 使用 + 拼接多行
    sql := "SELECT * FROM users " +
           "WHERE age > 18 " +
           "ORDER BY name"
    fmt.Println(sql)
}
```

**输出结果：**
```
第一行
第二行
    带缩进的第三行
特殊字符不转义: \n \t
SELECT * FROM users WHERE age > 18 ORDER BY name
```

## 性能建议

1. **字符串拼接**：大量拼接时使用 `strings.Builder` 而不是 `+`
2. **避免频繁转换**：string 和 []byte 之间的转换会复制数据
3. **使用 strings 包**：充分利用标准库提供的优化函数
4. **处理 Unicode**：需要按字符处理时，使用 `[]rune` 而不是索引访问

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    // 高效的字符串拼接
    var builder strings.Builder
    for i := 0; i < 1000; i++ {
        builder.WriteString("a")
    }
    result := builder.String()
    fmt.Printf("拼接结果长度: %d\n", len(result))
}
```

**输出结果：**
```
拼接结果长度: 1000