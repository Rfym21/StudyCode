# Go 映射类型

映射（map）是键值对的无序集合，类似于其他语言中的哈希表或字典。

## 映射基础

- 引用类型：map 是引用类型
- 动态增长：可以动态添加键值对
- 无序：遍历 map 的顺序是随机的
- 键的类型：必须支持 == 和 != 操作

## 创建映射

```go
package main

import "fmt"

func main() {
    // 创建映射的几种方式
    var map1 map[string]int              // 零值映射（nil）
    var map2 = map[string]int{           // 字面量创建
        "apple":  5,
        "banana": 3,
        "orange": 8,
    }
    var map3 = make(map[string]int)      // 使用 make 创建
    var map4 = make(map[string]int, 10)  // 预设容量为10

    fmt.Printf("map1: %v (nil=%t)\n", map1, map1 == nil)
    fmt.Printf("map2: %v\n", map2)
    fmt.Printf("map3: %v\n", map3)
    fmt.Printf("map4: %v\n", map4)
    
    // 不同类型的映射
    intMap := map[int]string{
        1: "one",
        2: "two",
        3: "three",
    }
    fmt.Printf("int->string 映射: %v\n", intMap)
}
```

## 基本操作

```go
package main

import "fmt"

func main() {
    // 创建映射
    scores := map[string]int{
        "Alice": 95,
        "Bob":   87,
        "Carol": 92,
    }
    
    // 添加或更新元素
    scores["David"] = 88     // 添加新元素
    scores["Alice"] = 96     // 更新已存在的元素
    
    // 获取元素
    aliceScore := scores["Alice"]
    fmt.Printf("Alice 的分数: %d\n", aliceScore)
    
    // 检查键是否存在
    score, exists := scores["Eve"]
    if exists {
        fmt.Printf("Eve 的分数: %d\n", score)
    } else {
        fmt.Println("Eve 不存在")
    }
    
    // 使用简短的方式检查
    if score, ok := scores["Bob"]; ok {
        fmt.Printf("Bob 的分数: %d\n", score)
    }
    
    // 删除元素
    delete(scores, "Carol")
    fmt.Printf("删除 Carol 后: %v\n", scores)
    
    // 获取映射长度
    fmt.Printf("映射长度: %d\n", len(scores))
}
```

## 遍历映射

```go
package main

import "fmt"

func main() {
    fruits := map[string]int{
        "apple":  5,
        "banana": 3,
        "orange": 8,
        "grape":  12,
    }
    
    // 遍历键值对
    fmt.Println("遍历键值对:")
    for key, value := range fruits {
        fmt.Printf("%s: %d\n", key, value)
    }
    
    // 只遍历键
    fmt.Println("\n只遍历键:")
    for key := range fruits {
        fmt.Println(key)
    }
    
    // 只遍历值
    fmt.Println("\n只遍历值:")
    for _, value := range fruits {
        fmt.Println(value)
    }
    
    // 收集所有键
    keys := make([]string, 0, len(fruits))
    for k := range fruits {
        keys = append(keys, k)
    }
    fmt.Printf("\n所有键: %v\n", keys)
}
```

## 映射的零值处理

```go
package main

import "fmt"

func main() {
    // 未初始化的映射（nil map）
    var nilMap map[string]int
    
    // 可以读取 nil map（返回零值）
    value := nilMap["key"]
    fmt.Printf("从 nil map 读取: %d\n", value)
    
    // 但不能写入 nil map
    // nilMap["key"] = 1  // panic: assignment to entry in nil map
    
    // 正确的做法：初始化后再使用
    nilMap = make(map[string]int)
    nilMap["key"] = 1
    fmt.Printf("初始化后: %v\n", nilMap)
    
    // 利用零值特性
    counter := map[string]int{}
    words := []string{"go", "python", "go", "java", "go", "python"}
    for _, word := range words {
        counter[word]++  // 不存在的键返回0，然后加1
    }
    fmt.Printf("词频统计: %v\n", counter)
}
```

## 复杂的映射类型

```go
package main

import "fmt"

func main() {
    // 值为切片的映射
    groups := map[string][]string{
        "fruits":     {"apple", "banana", "orange"},
        "vegetables": {"carrot", "broccoli"},
        "meats":      {"beef", "chicken", "pork"},
    }
    
    // 添加元素到切片
    groups["fruits"] = append(groups["fruits"], "grape")
    fmt.Printf("水果组: %v\n", groups["fruits"])
    
    // 嵌套映射
    users := map[string]map[string]string{
        "user1": {
            "name":  "Alice",
            "email": "alice@example.com",
            "role":  "admin",
        },
        "user2": {
            "name":  "Bob",
            "email": "bob@example.com",
            "role":  "user",
        },
    }
    
    fmt.Println("\n用户信息:")
    for id, info := range users {
        fmt.Printf("%s: %v\n", id, info)
    }
    
    // 结构体作为值
    type Person struct {
        Name string
        Age  int
    }
    
    people := map[string]Person{
        "p1": {"Alice", 30},
        "p2": {"Bob", 25},
    }
    fmt.Printf("\n人员信息: %v\n", people)
}
```

## 映射作为函数参数

```go
package main

import "fmt"

// 映射是引用类型，函数内的修改会影响原映射
func updateScores(scores map[string]int) {
    for key := range scores {
        scores[key] += 5  // 每人加5分
    }
}

// 返回映射
func wordCount(text string) map[rune]int {
    counts := make(map[rune]int)
    for _, char := range text {
        counts[char]++
    }
    return counts
}

// 使用映射实现集合
func uniqueElements(slice []int) []int {
    seen := make(map[int]bool)
    result := []int{}
    
    for _, value := range slice {
        if !seen[value] {
            seen[value] = true
            result = append(result, value)
        }
    }
    return result
}

func main() {
    // 修改映射
    scores := map[string]int{"Alice": 90, "Bob": 85}
    updateScores(scores)
    fmt.Printf("更新后的分数: %v\n", scores)
    
    // 字符计数
    charCount := wordCount("hello")
    fmt.Printf("字符统计: %v\n", charCount)
    
    // 去重
    numbers := []int{1, 2, 2, 3, 3, 3, 4, 5, 5}
    unique := uniqueElements(numbers)
    fmt.Printf("去重结果: %v\n", unique)
}
```

## 并发访问

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    // 普通 map 不是并发安全的
    // 使用 sync.Map 进行并发访问
    var m sync.Map
    
    // 存储
    m.Store("key1", "value1")
    m.Store("key2", "value2")
    
    // 读取
    if value, ok := m.Load("key1"); ok {
        fmt.Printf("key1: %v\n", value)
    }
    
    // 删除
    m.Delete("key2")
    
    // 遍历
    m.Range(func(key, value interface{}) bool {
        fmt.Printf("%v: %v\n", key, value)
        return true  // 继续遍历
    })
    
    // 使用互斥锁保护普通 map
    type SafeMap struct {
        mu sync.RWMutex
        m  map[string]int
    }
    
    safeMap := &SafeMap{
        m: make(map[string]int),
    }
    
    // 写操作
    safeMap.mu.Lock()
    safeMap.m["counter"] = 1
    safeMap.mu.Unlock()
    
    // 读操作
    safeMap.mu.RLock()
    value := safeMap.m["counter"]
    safeMap.mu.RUnlock()
    fmt.Printf("counter: %d\n", value)
}
```

## 实际应用场景

```go
package main

import (
    "fmt"
    "strings"
)

// 1. 缓存实现
type Cache struct {
    data map[string]interface{}
}

func NewCache() *Cache {
    return &Cache{
        data: make(map[string]interface{}),
    }
}

func (c *Cache) Set(key string, value interface{}) {
    c.data[key] = value
}

func (c *Cache) Get(key string) (interface{}, bool) {
    value, exists := c.data[key]
    return value, exists
}

// 2. 配置管理
type Config map[string]string

func (c Config) Get(key, defaultValue string) string {
    if value, ok := c[key]; ok {
        return value
    }
    return defaultValue
}

// 3. 倒排索引
func buildIndex(documents []string) map[string][]int {
    index := make(map[string][]int)
    
    for docID, doc := range documents {
        words := strings.Fields(strings.ToLower(doc))
        for _, word := range words {
            index[word] = append(index[word], docID)
        }
    }
    return index
}

func main() {
    // 使用缓存
    cache := NewCache()
    cache.Set("user:1", "Alice")
    if value, ok := cache.Get("user:1"); ok {
        fmt.Printf("缓存命中: %v\n", value)
    }
    
    // 使用配置
    config := Config{
        "host": "localhost",
        "port": "8080",
    }
    fmt.Printf("数据库主机: %s\n", config.Get("db_host", "127.0.0.1"))
    
    // 使用倒排索引
    docs := []string{
        "go is a programming language",
        "go is fast and simple",
        "i love go",
    }
    index := buildIndex(docs)
    fmt.Printf("包含 'go' 的文档: %v\n", index["go"])
}
```

## 性能和注意事项

1. **预分配容量**：使用 `make(map[K]V, size)` 预分配容量可以提高性能
2. **键的类型选择**：使用简单类型（如 int、string）作为键比复杂类型更高效
3. **并发安全**：标准 map 不是并发安全的，需要使用锁或 sync.Map
4. **内存占用**：map 会预分配一些空间，小 map 可能会浪费内存
5. **遍历顺序**：map 的遍历顺序是随机的，如需有序遍历，需要先排序键