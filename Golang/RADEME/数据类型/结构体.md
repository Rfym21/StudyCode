# Go 结构体类型

结构体是将零个或多个任意类型的命名字段组合在一起的复合类型。

## 结构体基础

- 值类型：结构体是值类型，赋值和传参会复制整个结构体
- 字段集合：可以包含不同类型的字段
- 可以包含方法：通过接收者定义方法

## 定义和创建结构体

```go
package main

import "fmt"

// 定义结构体
type Person struct {
    Name    string
    Age     int
    Email   string
    Active  bool
}

// 带标签的结构体
type User struct {
    ID       int    `json:"id" db:"user_id"`
    Username string `json:"username" db:"user_name"`
    Password string `json:"-" db:"password"` // json:"-" 表示忽略
}

func main() {
    // 创建结构体实例的几种方式
    
    // 1. 零值结构体
    var p1 Person
    fmt.Printf("零值: %+v\n", p1)
    
    // 2. 使用字段名
    p2 := Person{
        Name:   "张三",
        Age:    30,
        Email:  "zhangsan@example.com",
        Active: true,
    }
    fmt.Printf("字段名创建: %+v\n", p2)
    
    // 3. 按字段顺序（不推荐）
    p3 := Person{"李四", 25, "lisi@example.com", false}
    fmt.Printf("顺序创建: %+v\n", p3)
    
    // 4. 部分初始化
    p4 := Person{Name: "王五", Age: 28}
    fmt.Printf("部分初始化: %+v\n", p4)
    
    // 5. 使用 new
    p5 := new(Person)
    p5.Name = "赵六"
    fmt.Printf("new 创建: %+v\n", *p5)
}
```

## 访问和修改字段

```go
package main

import "fmt"

type Point struct {
    X, Y float64
}

type Circle struct {
    Center Point
    Radius float64
}

func main() {
    c := Circle{
        Center: Point{X: 0, Y: 0},
        Radius: 5,
    }
    
    // 访问字段
    fmt.Printf("圆心: (%.1f, %.1f)\n", c.Center.X, c.Center.Y)
    fmt.Printf("半径: %.1f\n", c.Radius)
    
    // 修改字段
    c.Center.X = 10
    c.Radius = 8
    fmt.Printf("修改后: %+v\n", c)
    
    // 使用指针访问
    p := &c
    p.Center.Y = 20  // 自动解引用
    fmt.Printf("指针修改后: %+v\n", c)
}
```

## 嵌入式结构体

```go
package main

import "fmt"

// 基础结构体
type Address struct {
    Street  string
    City    string
    ZipCode string
}

// 嵌入其他结构体
type Employee struct {
    Name    string
    ID      int
    Address Address  // 命名嵌入
}

// 匿名嵌入
type Manager struct {
    Employee     // 匿名嵌入
    Department string
}

// 多重嵌入
type ContactInfo struct {
    Email string
    Phone string
}

type Customer struct {
    Name string
    ContactInfo
    Address
}

func main() {
    // 命名嵌入
    emp := Employee{
        Name: "张三",
        ID:   1001,
        Address: Address{
            Street: "中山路123号",
            City:   "北京",
            ZipCode: "100000",
        },
    }
    fmt.Printf("员工信息: %+v\n", emp)
    
    // 匿名嵌入
    mgr := Manager{
        Employee: Employee{
            Name: "李四",
            ID:   2001,
            Address: Address{
                City: "上海",
            },
        },
        Department: "技术部",
    }
    
    // 可以直接访问嵌入结构体的字段
    fmt.Printf("经理名字: %s\n", mgr.Name)  // 等同于 mgr.Employee.Name
    fmt.Printf("部门: %s\n", mgr.Department)
    
    // 多重嵌入
    customer := Customer{
        Name:  "王五",
        Email: "wangwu@example.com",
        Phone: "13812345678",
        Address: Address{
            City: "深圳",
        },
    }
    fmt.Printf("客户邮箱: %s\n", customer.Email)
    fmt.Printf("客户城市: %s\n", customer.City)
}
```

## 结构体方法

```go
package main

import (
    "fmt"
    "math"
)

type Rectangle struct {
    Width, Height float64
}

// 值接收者方法
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// 值接收者方法
func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

// 指针接收者方法（可以修改结构体）
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}

// 结构体工厂函数
func NewRectangle(w, h float64) *Rectangle {
    return &Rectangle{Width: w, Height: h}
}

type Point struct {
    X, Y float64
}

// 为 Point 添加方法
func (p Point) Distance(q Point) float64 {
    return math.Sqrt((p.X-q.X)*(p.X-q.X) + (p.Y-q.Y)*(p.Y-q.Y))
}

func main() {
    rect := Rectangle{Width: 10, Height: 5}
    
    // 调用值接收者方法
    fmt.Printf("面积: %.2f\n", rect.Area())
    fmt.Printf("周长: %.2f\n", rect.Perimeter())
    
    // 调用指针接收者方法
    rect.Scale(2)
    fmt.Printf("放大后: %+v\n", rect)
    
    // 使用工厂函数
    rect2 := NewRectangle(3, 4)
    fmt.Printf("新矩形: %+v\n", *rect2)
    
    // Point 方法
    p1 := Point{0, 0}
    p2 := Point{3, 4}
    fmt.Printf("距离: %.2f\n", p1.Distance(p2))
}
```

## 结构体比较

```go
package main

import "fmt"

type Person struct {
    Name string
    Age  int
}

type Employee struct {
    Person
    ID int
}

// 包含不可比较字段的结构体
type Group struct {
    Name    string
    Members []string  // 切片不可比较
}

func main() {
    // 可比较的结构体
    p1 := Person{"Alice", 30}
    p2 := Person{"Alice", 30}
    p3 := Person{"Bob", 25}
    
    fmt.Printf("p1 == p2: %t\n", p1 == p2)  // true
    fmt.Printf("p1 == p3: %t\n", p1 == p3)  // false
    
    // 嵌套结构体的比较
    e1 := Employee{Person{"Alice", 30}, 1001}
    e2 := Employee{Person{"Alice", 30}, 1001}
    fmt.Printf("e1 == e2: %t\n", e1 == e2)  // true
    
    // 包含不可比较字段的结构体不能直接比较
    // g1 := Group{"Team A", []string{"Alice", "Bob"}}
    // g2 := Group{"Team A", []string{"Alice", "Bob"}}
    // fmt.Printf("g1 == g2: %t\n", g1 == g2)  // 编译错误
}
```

## 结构体与 JSON

```go
package main

import (
    "encoding/json"
    "fmt"
)

type Person struct {
    Name     string   `json:"name"`
    Age      int      `json:"age"`
    Email    string   `json:"email,omitempty"`  // 空值时忽略
    Password string   `json:"-"`                 // 总是忽略
    Tags     []string `json:"tags,omitempty"`
}

func main() {
    // 结构体转 JSON
    p := Person{
        Name:     "张三",
        Age:      30,
        Password: "secret123",
        Tags:     []string{"developer", "gopher"},
    }
    
    jsonData, err := json.Marshal(p)
    if err != nil {
        fmt.Printf("JSON 编码错误: %v\n", err)
        return
    }
    fmt.Printf("JSON: %s\n", jsonData)
    
    // 格式化的 JSON
    prettyJSON, _ := json.MarshalIndent(p, "", "  ")
    fmt.Printf("格式化 JSON:\n%s\n", prettyJSON)
    
    // JSON 转结构体
    jsonStr := `{"name":"李四","age":25,"tags":["designer"]}`
    var p2 Person
    err = json.Unmarshal([]byte(jsonStr), &p2)
    if err != nil {
        fmt.Printf("JSON 解码错误: %v\n", err)
        return
    }
    fmt.Printf("解码结果: %+v\n", p2)
}
```

## 空结构体

```go
package main

import (
    "fmt"
    "unsafe"
)

func main() {
    // 空结构体不占用内存
    var s struct{}
    fmt.Printf("空结构体大小: %d\n", unsafe.Sizeof(s))
    
    // 用作集合的值
    set := make(map[string]struct{})
    set["apple"] = struct{}{}
    set["banana"] = struct{}{}
    
    // 检查存在性
    if _, exists := set["apple"]; exists {
        fmt.Println("apple 存在")
    }
    
    // 用作信号
    done := make(chan struct{})
    go func() {
        fmt.Println("工作中...")
        done <- struct{}{}
    }()
    <-done
    fmt.Println("工作完成")
}
```

## 高级用法

```go
package main

import (
    "fmt"
    "reflect"
)

// 使用接口实现多态
type Shape interface {
    Area() float64
}

type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return 3.14159 * c.Radius * c.Radius
}

// 使用反射处理结构体
func PrintStructInfo(s interface{}) {
    t := reflect.TypeOf(s)
    v := reflect.ValueOf(s)
    
    fmt.Printf("类型: %s\n", t.Name())
    fmt.Printf("字段数: %d\n", t.NumField())
    
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        value := v.Field(i)
        fmt.Printf("  %s (%s): %v\n", field.Name, field.Type, value)
    }
}

func main() {
    // 多态使用
    shapes := []Shape{
        Rectangle{Width: 10, Height: 5},
        Circle{Radius: 3},
    }
    
    for _, shape := range shapes {
        fmt.Printf("面积: %.2f\n", shape.Area())
    }
    
    // 反射示例
    fmt.Println("\n结构体信息:")
    PrintStructInfo(Rectangle{Width: 10, Height: 5})
}
```

## 最佳实践

1. **使用指针接收者**：当方法需要修改结构体或结构体很大时
2. **工厂函数**：使用 NewXxx 函数创建和初始化结构体
3. **嵌入而非继承**：Go 没有继承，使用组合和嵌入
4. **标签的使用**：为 JSON、数据库等序列化添加标签
5. **避免过大的结构体**：考虑拆分成多个小结构体
6. **文档注释**：为导出的结构体和字段添加注释