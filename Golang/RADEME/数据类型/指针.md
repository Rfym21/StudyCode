# Go 指针类型

指针是存储另一个变量的内存地址的变量。

## 指针基础

- 指针存储变量的内存地址
- `*T` 表示指向类型 T 的指针
- `&` 操作符获取变量的地址
- `*` 操作符获取指针指向的值（解引用）

## 声明和使用指针

```go
package main

import "fmt"

func main() {
    // 声明指针
    var p *int      // 指向 int 的指针，零值是 nil
    fmt.Printf("零值指针: %v\n", p)
    
    // 获取变量地址
    x := 42
    p = &x          // p 现在指向 x
    
    fmt.Printf("x 的值: %d\n", x)
    fmt.Printf("x 的地址: %p\n", &x)
    fmt.Printf("p 的值（x的地址）: %p\n", p)
    fmt.Printf("p 指向的值: %d\n", *p)
    
    // 通过指针修改值
    *p = 100
    fmt.Printf("通过指针修改后，x 的值: %d\n", x)
    
    // 指针的指针
    var pp **int = &p
    fmt.Printf("pp 指向的指针指向的值: %d\n", **pp)
}
```

## new 函数

```go
package main

import "fmt"

func main() {
    // 使用 new 创建指针
    p := new(int)       // 分配内存并返回指针
    fmt.Printf("new 创建的指针: %p, 值: %d\n", p, *p)
    
    *p = 42
    fmt.Printf("赋值后: %d\n", *p)
    
    // new 可以用于任何类型
    type Person struct {
        Name string
        Age  int
    }
    
    person := new(Person)
    person.Name = "张三"  // 自动解引用
    person.Age = 30
    fmt.Printf("Person: %+v\n", *person)
}
```

## 指针与函数

```go
package main

import "fmt"

// 值传递（不会修改原值）
func changeValue(x int) {
    x = 100
}

// 指针传递（会修改原值）
func changePointer(x *int) {
    *x = 100
}

// 交换两个变量的值
func swap(a, b *int) {
    *a, *b = *b, *a
}

// 返回指针
func newInt(value int) *int {
    return &value  // 注意：这在 Go 中是安全的
}

func main() {
    x := 42
    
    changeValue(x)
    fmt.Printf("值传递后: %d\n", x)  // 不变
    
    changePointer(&x)
    fmt.Printf("指针传递后: %d\n", x)  // 改变
    
    a, b := 10, 20
    fmt.Printf("交换前: a=%d, b=%d\n", a, b)
    swap(&a, &b)
    fmt.Printf("交换后: a=%d, b=%d\n", a, b)
    
    p := newInt(999)
    fmt.Printf("返回的指针指向: %d\n", *p)
}
```

## 指针与结构体

```go
package main

import "fmt"

type Person struct {
    Name string
    Age  int
}

// 修改结构体字段
func birthday(p *Person) {
    p.Age++  // 等同于 (*p).Age++
}

// 结构体方法的指针接收者
func (p *Person) SetName(name string) {
    p.Name = name
}

func (p Person) GetInfo() string {
    return fmt.Sprintf("%s, %d岁", p.Name, p.Age)
}

func main() {
    // 结构体指针
    person := &Person{
        Name: "张三",
        Age:  30,
    }
    
    fmt.Printf("初始: %+v\n", *person)
    
    // 通过指针访问字段（自动解引用）
    person.Name = "李四"
    fmt.Printf("修改名字后: %s\n", person.Name)
    
    // 函数修改
    birthday(person)
    fmt.Printf("过生日后: %d岁\n", person.Age)
    
    // 方法调用
    person.SetName("王五")
    fmt.Println(person.GetInfo())
}
```

## 指针与数组/切片

```go
package main

import "fmt"

func main() {
    // 数组指针
    arr := [3]int{1, 2, 3}
    var p *[3]int = &arr
    
    fmt.Printf("数组指针: %v\n", *p)
    p[0] = 100  // 修改数组元素
    fmt.Printf("修改后: %v\n", arr)
    
    // 指针数组
    x, y, z := 1, 2, 3
    ptrArray := [3]*int{&x, &y, &z}
    
    fmt.Printf("指针数组: ")
    for _, ptr := range ptrArray {
        fmt.Printf("%d ", *ptr)
    }
    fmt.Println()
    
    // 切片本身就是引用类型
    slice := []int{1, 2, 3}
    modifySlice(&slice)
    fmt.Printf("修改后的切片: %v\n", slice)
}

func modifySlice(s *[]int) {
    *s = append(*s, 4, 5)
}
```

## 空指针检查

```go
package main

import "fmt"

type Node struct {
    Value int
    Next  *Node
}

func printList(head *Node) {
    // 空指针检查
    if head == nil {
        fmt.Println("空链表")
        return
    }
    
    current := head
    for current != nil {
        fmt.Printf("%d ", current.Value)
        current = current.Next
    }
    fmt.Println()
}

func safeDereference(p *int) {
    if p != nil {
        fmt.Printf("值: %d\n", *p)
    } else {
        fmt.Println("空指针")
    }
}

func main() {
    // 创建链表
    node3 := &Node{Value: 3, Next: nil}
    node2 := &Node{Value: 2, Next: node3}
    node1 := &Node{Value: 1, Next: node2}
    
    printList(node1)
    printList(nil)
    
    // 安全的解引用
    var p *int
    safeDereference(p)
    
    x := 42
    safeDereference(&x)
}
```

## 指针的常见用途

```go
package main

import (
    "fmt"
    "errors"
)

// 1. 大型结构体的高效传递
type LargeStruct struct {
    Data [1000]int
    // ... 更多字段
}

func processLargeStruct(ls *LargeStruct) {
    // 处理大型结构体，避免复制
    ls.Data[0] = 100
}

// 2. 实现可选参数
type Config struct {
    Host     string
    Port     int
    Timeout  int
}

func NewServer(config *Config) {
    if config == nil {
        config = &Config{
            Host:    "localhost",
            Port:    8080,
            Timeout: 30,
        }
    }
    fmt.Printf("服务器配置: %+v\n", *config)
}

// 3. 返回多个值和错误
func divide(a, b float64) (*float64, error) {
    if b == 0 {
        return nil, errors.New("除数不能为零")
    }
    result := a / b
    return &result, nil
}

func main() {
    // 大型结构体
    ls := &LargeStruct{}
    processLargeStruct(ls)
    fmt.Printf("第一个元素: %d\n", ls.Data[0])
    
    // 可选配置
    NewServer(nil)  // 使用默认配置
    NewServer(&Config{Host: "192.168.1.1", Port: 9000, Timeout: 60})
    
    // 处理返回值
    if result, err := divide(10, 2); err == nil {
        fmt.Printf("10 / 2 = %.2f\n", *result)
    }
    
    if result, err := divide(10, 0); err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("结果: %.2f\n", *result)
    }
}
```

## 内存逃逸

```go
package main

import "fmt"

// 返回局部变量的指针是安全的
// Go 编译器会进行逃逸分析
func createPointer() *int {
    x := 42  // x 会逃逸到堆上
    return &x
}

// 不会逃逸的例子
func noEscape() int {
    x := 42
    y := &x
    return *y  // x 不会逃逸，保留在栈上
}

func main() {
    p := createPointer()
    fmt.Printf("指针指向的值: %d\n", *p)  // 安全访问
    
    // 查看逃逸分析：go build -gcflags="-m"
}
```

## 最佳实践

1. **nil 检查**：使用指针前检查是否为 nil
2. **方法接收者**：
   - 需要修改接收者：使用指针接收者
   - 接收者是大型结构体：使用指针接收者
   - 接收者包含 sync.Mutex 等：必须使用指针接收者
3. **避免指针运算**：Go 不支持指针算术运算
4. **返回局部变量地址**：在 Go 中是安全的
5. **接口与指针**：接口变量可以持有指针或值

## 指针 vs 值

| 特性 | 值 | 指针 |
|------|-----|------|
| 内存分配 | 可能在栈上 | 指向的值可能在堆上 |
| 传递开销 | 复制整个值 | 只复制地址（8字节） |
| 可修改性 | 不能修改原值 | 可以修改原值 |
| nil 值 | 有具体零值 | 可以是 nil |
| 并发安全 | 每个副本独立 | 需要同步机制 |