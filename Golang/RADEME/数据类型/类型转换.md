# Go 类型转换

Go 是强类型语言，不同类型之间的转换需要显式进行。

## 基本类型转换

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // 整数类型之间的转换
    var i int = 42
    var i8 int8 = int8(i)
    var i16 int16 = int16(i)
    var i32 int32 = int32(i)
    var i64 int64 = int64(i)
    
    fmt.Printf("int: %d, int8: %d, int16: %d, int32: %d, int64: %d\n",
        i, i8, i16, i32, i64)
    
    // 无符号整数转换
    var u uint = uint(i)
    var u8 uint8 = uint8(i)
    var u16 uint16 = uint16(i)
    var u32 uint32 = uint32(i)
    var u64 uint64 = uint64(i)
    
    fmt.Printf("uint: %d, uint8: %d, uint16: %d, uint32: %d, uint64: %d\n",
        u, u8, u16, u32, u64)
    
    // 浮点数转换
    var f32 float32 = float32(i)
    var f64 float64 = float64(i)
    
    fmt.Printf("float32: %.2f, float64: %.2f\n", f32, f64)
    
    // 浮点数转整数（截断小数部分）
    var f = 3.14159
    var intFromFloat = int(f)
    fmt.Printf("float %.5f -> int %d\n", f, intFromFloat)
    
    // 注意溢出
    var bigInt int64 = math.MaxInt64
    var smallInt int8 = int8(bigInt)  // 溢出
    fmt.Printf("溢出示例: %d -> %d\n", bigInt, smallInt)
}
```

## 字符串转换

```go
package main

import (
    "fmt"
    "strconv"
)

func main() {
    // 数字转字符串
    i := 42
    s1 := strconv.Itoa(i)  // int to ASCII
    s2 := strconv.FormatInt(int64(i), 10)  // 指定进制
    s3 := fmt.Sprintf("%d", i)  // 使用 fmt
    
    fmt.Printf("整数转字符串: %s, %s, %s\n", s1, s2, s3)
    
    // 浮点数转字符串
    f := 3.14159
    s4 := strconv.FormatFloat(f, 'f', 2, 64)  // 2位小数
    s5 := fmt.Sprintf("%.2f", f)
    
    fmt.Printf("浮点数转字符串: %s, %s\n", s4, s5)
    
    // 字符串转数字
    str := "123"
    if num, err := strconv.Atoi(str); err == nil {
        fmt.Printf("字符串 '%s' 转整数: %d\n", str, num)
    }
    
    // 字符串转其他数字类型
    str2 := "3.14159"
    if f64, err := strconv.ParseFloat(str2, 64); err == nil {
        fmt.Printf("字符串 '%s' 转浮点数: %.5f\n", str2, f64)
    }
    
    // 字符串转布尔值
    boolStr := "true"
    if b, err := strconv.ParseBool(boolStr); err == nil {
        fmt.Printf("字符串 '%s' 转布尔值: %t\n", boolStr, b)
    }
    
    // 错误处理
    invalidStr := "abc"
    if _, err := strconv.Atoi(invalidStr); err != nil {
        fmt.Printf("转换错误: %v\n", err)
    }
}
```

## 字节和字符串转换

```go
package main

import (
    "fmt"
    "unicode/utf8"
)

func main() {
    // 字符串转字节切片
    s := "Hello, 世界"
    bytes := []byte(s)
    fmt.Printf("字符串: %s\n", s)
    fmt.Printf("字节: %v\n", bytes)
    
    // 字节切片转字符串
    s2 := string(bytes)
    fmt.Printf("还原字符串: %s\n", s2)
    
    // rune 和字符串转换
    r := '中'
    s3 := string(r)
    fmt.Printf("rune '%c' 转字符串: %s\n", r, s3)
    
    // 字符串转 rune 切片
    runes := []rune(s)
    fmt.Printf("rune 切片: %v\n", runes)
    fmt.Printf("字符数: %d\n", len(runes))
    fmt.Printf("字节数: %d\n", len(s))
    fmt.Printf("UTF-8 字符数: %d\n", utf8.RuneCountInString(s))
    
    // 遍历字符串的不同方式
    fmt.Println("\n按字节遍历:")
    for i := 0; i < len(s); i++ {
        fmt.Printf("%c ", s[i])
    }
    
    fmt.Println("\n\n按 rune 遍历:")
    for _, r := range s {
        fmt.Printf("%c ", r)
    }
    fmt.Println()
}
```

## 自定义类型转换

```go
package main

import "fmt"

// 定义自定义类型
type Celsius float64
type Fahrenheit float64
type Meters float64
type Feet float64

// 类型转换方法
func (c Celsius) ToFahrenheit() Fahrenheit {
    return Fahrenheit(c*9/5 + 32)
}

func (f Fahrenheit) ToCelsius() Celsius {
    return Celsius((f - 32) * 5 / 9)
}

func (m Meters) ToFeet() Feet {
    return Feet(m * 3.28084)
}

func (f Feet) ToMeters() Meters {
    return Meters(f / 3.28084)
}

func main() {
    // 基础类型和自定义类型转换
    var temp float64 = 25.0
    c := Celsius(temp)
    
    fmt.Printf("%.2f°C = %.2f°F\n", c, c.ToFahrenheit())
    
    f := Fahrenheit(77)
    fmt.Printf("%.2f°F = %.2f°C\n", f, f.ToCelsius())
    
    // 长度转换
    m := Meters(100)
    fmt.Printf("%.2f 米 = %.2f 英尺\n", m, m.ToFeet())
    
    // 底层类型相同可以转换
    type MyInt int
    var myNum MyInt = 42
    var stdNum int = int(myNum)  // 需要显式转换
    fmt.Printf("MyInt: %d, int: %d\n", myNum, stdNum)
}
```

## 接口类型转换

```go
package main

import "fmt"

// 类型断言
func printType(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf("整数: %d\n", v)
    case string:
        fmt.Printf("字符串: %s\n", v)
    case float64:
        fmt.Printf("浮点数: %.2f\n", v)
    case bool:
        fmt.Printf("布尔值: %t\n", v)
    default:
        fmt.Printf("未知类型: %T\n", v)
    }
}

// 接口转换示例
type Reader interface {
    Read() string
}

type Writer interface {
    Write(string)
}

type ReadWriter interface {
    Reader
    Writer
}

type File struct {
    name string
}

func (f *File) Read() string {
    return "读取 " + f.name
}

func (f *File) Write(content string) {
    fmt.Printf("写入 %s 到 %s\n", content, f.name)
}

func main() {
    // 类型断言
    var i interface{} = 42
    
    // 安全的类型断言
    if v, ok := i.(int); ok {
        fmt.Printf("是整数: %d\n", v)
    }
    
    // 类型 switch
    printType(42)
    printType("hello")
    printType(3.14)
    printType(true)
    
    // 接口转换
    file := &File{name: "test.txt"}
    var r Reader = file
    var w Writer = file
    var rw ReadWriter = file
    
    // 向下转型
    if f, ok := r.(*File); ok {
        fmt.Printf("Reader 转 *File: %s\n", f.name)
    }
    
    // 接口之间转换
    if reader, ok := rw.(Reader); ok {
        fmt.Printf("ReadWriter 转 Reader: %s\n", reader.Read())
    }
    
    _ = w  // 避免未使用的变量警告
}
```

## 指针类型转换

```go
package main

import (
    "fmt"
    "unsafe"
)

func main() {
    // 不同类型指针不能直接转换
    var i int = 42
    var pi *int = &i
    // var pf *float64 = pi  // 编译错误
    
    // 使用 unsafe.Pointer 进行转换（谨慎使用）
    var pf *float64 = (*float64)(unsafe.Pointer(pi))
    fmt.Printf("int 指针转 float64 指针: %v\n", *pf)
    
    // uintptr 转换
    addr := uintptr(unsafe.Pointer(pi))
    fmt.Printf("指针地址: 0x%x\n", addr)
    
    // 从 uintptr 转回指针
    pi2 := (*int)(unsafe.Pointer(addr))
    fmt.Printf("恢复的值: %d\n", *pi2)
    
    // 数组指针转换
    arr := [3]int{1, 2, 3}
    slice := arr[:]  // 数组转切片
    fmt.Printf("切片: %v\n", slice)
    
    // 获取切片底层数组指针
    arrPtr := (*[3]int)(unsafe.Pointer(&slice[0]))
    fmt.Printf("底层数组: %v\n", *arrPtr)
}
```

## 常见转换错误和注意事项

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // 1. 精度损失
    var f float64 = 3.99
    var i int = int(f)  // 3，小数部分被截断
    fmt.Printf("精度损失: %.2f -> %d\n", f, i)
    
    // 2. 溢出
    var big int64 = math.MaxInt64
    var small int8 = int8(big)  // 溢出，结果为 -1
    fmt.Printf("溢出: %d -> %d\n", big, small)
    
    // 3. 符号问题
    var negative int = -1
    var unsigned uint = uint(negative)  // 变成很大的正数
    fmt.Printf("符号问题: %d -> %d\n", negative, unsigned)
    
    // 4. nil 接口转换
    var i interface{}
    // 检查 nil
    if i == nil {
        fmt.Println("接口是 nil")
    }
    
    var p *int
    i = p
    // 注意：包含 nil 指针的接口不是 nil
    if i != nil {
        fmt.Printf("接口不是 nil，但值是: %v\n", i)
    }
    
    // 5. 字符串和数字转换的验证
    str := "123abc"
    if num, err := strconv.Atoi(str); err != nil {
        fmt.Printf("转换失败: %v\n", err)
    } else {
        fmt.Printf("转换成功: %d\n", num)
    }
}

// 安全的类型转换函数示例
func SafeInt8(i int) (int8, error) {
    if i > math.MaxInt8 || i < math.MinInt8 {
        return 0, fmt.Errorf("值 %d 超出 int8 范围", i)
    }
    return int8(i), nil
}

func SafeUint(i int) (uint, error) {
    if i < 0 {
        return 0, fmt.Errorf("负数 %d 不能转换为 uint", i)
    }
    return uint(i), nil
}
```

## 最佳实践

1. **显式转换**：Go 要求显式类型转换，避免隐式转换的问题
2. **检查范围**：在转换前检查值是否在目标类型的范围内
3. **使用标准库**：优先使用 strconv 包进行字符串转换
4. **错误处理**：处理转换可能产生的错误
5. **避免 unsafe**：除非必要，避免使用 unsafe 包
6. **文档说明**：在进行复杂转换时添加注释说明原因

## 类型别名 vs 类型定义

```go
package main

import "fmt"

// 类型别名（type alias）
type MyInt = int  // MyInt 和 int 是完全相同的类型

// 类型定义（type definition）
type Age int      // Age 是新类型，底层类型是 int

func main() {
    // 类型别名
    var a MyInt = 42
    var b int = a  // 不需要转换，是同一类型
    fmt.Printf("类型别名: a=%d, b=%d\n", a, b)
    
    // 类型定义
    var age Age = 25
    // var num int = age  // 编译错误，需要转换
    var num int = int(age)  // 显式转换
    fmt.Printf("类型定义: age=%d, num=%d\n", age, num)
}