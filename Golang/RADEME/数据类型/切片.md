# Go 切片类型

切片是对数组的抽象，提供了更灵活的动态数组功能。

## 切片基础

- 动态大小：切片的长度可以改变
- 引用类型：切片是对底层数组的引用
- 三个组成部分：指向底层数组的指针、长度（len）、容量（cap）

## 创建切片

```go
package main

import "fmt"

func main() {
    // 创建切片的几种方式
    var slice1 []int                    // 零值切片（nil）
    var slice2 = []int{1, 2, 3, 4, 5}  // 字面量创建
    var slice3 = make([]int, 5)        // 使用 make 创建，长度为5
    var slice4 = make([]int, 3, 10)    // 长度为3，容量为10

    fmt.Printf("slice1: %v (len=%d, cap=%d, nil=%t)\n",
        slice1, len(slice1), cap(slice1), slice1 == nil)
    fmt.Printf("slice2: %v (len=%d, cap=%d)\n",
        slice2, len(slice2), cap(slice2))
    fmt.Printf("slice3: %v (len=%d, cap=%d)\n",
        slice3, len(slice3), cap(slice3))
    fmt.Printf("slice4: %v (len=%d, cap=%d)\n",
        slice4, len(slice4), cap(slice4))
}
```

**输出结果：**
```
slice1: [] (len=0, cap=0, nil=true)
slice2: [1 2 3 4 5] (len=5, cap=5)
slice3: [0 0 0 0 0] (len=5, cap=5)
slice4: [0 0 0] (len=3, cap=10)
```

## 从数组创建切片

```go
package main

import "fmt"

func main() {
    // 从数组创建切片
    arr := [5]int{1, 2, 3, 4, 5}
    
    slice1 := arr[1:4]   // 索引1到3
    slice2 := arr[:3]    // 开始到索引2
    slice3 := arr[2:]    // 索引2到结束
    slice4 := arr[:]     // 整个数组
    
    fmt.Printf("原数组: %v\n", arr)
    fmt.Printf("arr[1:4]: %v\n", slice1)
    fmt.Printf("arr[:3]: %v\n", slice2)
    fmt.Printf("arr[2:]: %v\n", slice3)
    fmt.Printf("arr[:]: %v\n", slice4)
    
    // 修改切片会影响原数组
    slice1[0] = 100
    fmt.Printf("修改切片后的数组: %v\n", arr)
}
```

**输出结果：**
```
原数组: [1 2 3 4 5]
arr[1:4]: [2 3 4]
arr[:3]: [1 2 3]
arr[2:]: [3 4 5]
arr[:]: [1 2 3 4 5]
修改切片后的数组: [1 100 3 4 5]
```

## 切片操作

```go
package main

import "fmt"

func main() {
    slice := []int{1, 2, 3}
    fmt.Printf("初始切片: %v (len=%d, cap=%d)\n", 
        slice, len(slice), cap(slice))
    
    // append 追加元素
    slice = append(slice, 4)
    slice = append(slice, 5, 6, 7)
    fmt.Printf("追加后: %v (len=%d, cap=%d)\n", 
        slice, len(slice), cap(slice))
    
    // 追加另一个切片
    slice2 := []int{8, 9, 10}
    slice = append(slice, slice2...)
    fmt.Printf("追加切片后: %v\n", slice)
    
    // copy 复制切片
    dest := make([]int, 5)
    n := copy(dest, slice)
    fmt.Printf("复制了 %d 个元素: %v\n", n, dest)
    
    // 删除元素（通过切片操作）
    // 删除索引为3的元素
    index := 3
    slice = append(slice[:index], slice[index+1:]...)
    fmt.Printf("删除索引3后: %v\n", slice)
}
```

**输出结果：**
```
初始切片: [1 2 3] (len=3, cap=3)
追加后: [1 2 3 4 5 6 7] (len=7, cap=12)
追加切片后: [1 2 3 4 5 6 7 8 9 10]
复制了 5 个元素: [1 2 3 4 5]
删除索引3后: [1 2 3 5 6 7 8 9 10]
```

## 切片的长度和容量

```go
package main

import "fmt"

func main() {
    slice := make([]int, 3, 5)
    fmt.Printf("初始: len=%d, cap=%d, %v\n", 
        len(slice), cap(slice), slice)
    
    // 可以通过切片操作扩展长度到容量
    slice = slice[:5]
    fmt.Printf("扩展后: len=%d, cap=%d, %v\n", 
        len(slice), cap(slice), slice)
    
    // append 超过容量时会重新分配
    slice = append(slice, 6, 7, 8)
    fmt.Printf("超容量追加: len=%d, cap=%d, %v\n", 
        len(slice), cap(slice), slice)
    
    // 切片的容量增长策略
    s := []int{}
    oldCap := 0
    for i := 0; i < 20; i++ {
        s = append(s, i)
        if cap(s) != oldCap {
            fmt.Printf("len=%d, cap变化: %d -> %d\n",
                len(s), oldCap, cap(s))
            oldCap = cap(s)
        }
    }
}
```

**输出结果：**
```
初始: len=3, cap=5, [0 0 0]
扩展后: len=5, cap=5, [0 0 0 0 0]
超容量追加: len=8, cap=10, [0 0 0 0 0 6 7 8]
len=1, cap变化: 0 -> 1
len=2, cap变化: 1 -> 2
len=3, cap变化: 2 -> 4
len=5, cap变化: 4 -> 8
len=9, cap变化: 8 -> 16
len=17, cap变化: 16 -> 32
```

## 切片的内部结构

```go
package main

import (
    "fmt"
    "unsafe"
)

func main() {
    slice := []int{1, 2, 3, 4, 5}
    
    // 切片的内存布局
    fmt.Printf("切片大小: %d bytes\n", unsafe.Sizeof(slice))
    
    // 演示切片共享底层数组
    slice1 := slice[1:3]
    slice2 := slice[2:4]
    
    fmt.Printf("slice: %v\n", slice)
    fmt.Printf("slice1: %v\n", slice1)
    fmt.Printf("slice2: %v\n", slice2)
    
    // 修改会相互影响
    slice1[1] = 100
    fmt.Printf("\n修改 slice1[1] 后:\n")
    fmt.Printf("slice: %v\n", slice)
    fmt.Printf("slice1: %v\n", slice1)
    fmt.Printf("slice2: %v\n", slice2)
}
```

**输出结果：**
```
切片大小: 24 bytes
slice: [1 2 3 4 5]
slice1: [2 3]
slice2: [3 4]

修改 slice1[1] 后:
slice: [1 2 100 4 5]
slice1: [2 100]
slice2: [100 4]
```

## 多维切片

```go
package main

import "fmt"

func main() {
    // 二维切片
    matrix := [][]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }
    
    fmt.Println("二维切片:")
    for i, row := range matrix {
        fmt.Printf("第%d行: %v\n", i, row)
    }
    
    // 创建不规则的二维切片
    irregular := make([][]int, 3)
    irregular[0] = []int{1}
    irregular[1] = []int{2, 3}
    irregular[2] = []int{4, 5, 6}
    
    fmt.Println("\n不规则二维切片:")
    for i, row := range irregular {
        fmt.Printf("第%d行: %v\n", i, row)
    }
}
```

**输出结果：**
```
二维切片:
第0行: [1 2 3]
第1行: [4 5 6]
第2行: [7 8 9]

不规则二维切片:
第0行: [1]
第1行: [2 3]
第2行: [4 5 6]
```

## 切片作为函数参数

```go
package main

import "fmt"

// 切片是引用类型，传递的是引用
func modifySlice(s []int) {
    if len(s) > 0 {
        s[0] = 999
    }
}

// 返回切片
func generateSlice(n int) []int {
    slice := make([]int, n)
    for i := range slice {
        slice[i] = i + 1
    }
    return slice
}

// 可变参数实际上是切片
func sum(nums ...int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}

func main() {
    slice := []int{1, 2, 3, 4, 5}
    modifySlice(slice)
    fmt.Printf("修改后: %v\n", slice)
    
    newSlice := generateSlice(5)
    fmt.Printf("生成的切片: %v\n", newSlice)
    
    result := sum(1, 2, 3, 4, 5)
    fmt.Printf("求和结果: %d\n", result)
    
    // 使用切片作为可变参数
    nums := []int{10, 20, 30}
    result2 := sum(nums...)
    fmt.Printf("切片求和: %d\n", result2)
}
```

**输出结果：**
```
修改后: [999 2 3 4 5]
生成的切片: [1 2 3 4 5]
求和结果: 15
切片求和: 60
```

## 切片的常见操作

```go
package main

import "fmt"

func main() {
    // 1. 过滤切片
    nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    evens := []int{}
    for _, n := range nums {
        if n%2 == 0 {
            evens = append(evens, n)
        }
    }
    fmt.Printf("偶数: %v\n", evens)
    
    // 2. 反转切片
    slice := []int{1, 2, 3, 4, 5}
    for i, j := 0, len(slice)-1; i < j; i, j = i+1, j-1 {
        slice[i], slice[j] = slice[j], slice[i]
    }
    fmt.Printf("反转后: %v\n", slice)
    
    // 3. 查找元素
    target := 3
    found := false
    for i, v := range slice {
        if v == target {
            fmt.Printf("找到 %d 在索引 %d\n", target, i)
            found = true
            break
        }
    }
    if !found {
        fmt.Printf("未找到 %d\n", target)
    }
    
    // 4. 去重
    unique := []int{1, 2, 2, 3, 3, 3, 4, 5, 5}
    seen := make(map[int]bool)
    result := []int{}
    for _, v := range unique {
        if !seen[v] {
            seen[v] = true
            result = append(result, v)
        }
    }
    fmt.Printf("去重后: %v\n", result)
}
```

**输出结果：**
```
偶数: [2 4 6 8 10]
反转后: [5 4 3 2 1]
找到 3 在索引 2
去重后: [1 2 3 4 5]
```

## 性能建议

1. **预分配容量**：如果知道切片的大致大小，使用 `make` 预分配容量
2. **避免内存泄漏**：从大切片创建小切片时，考虑复制数据以释放原切片
3. **重用切片**：使用 `slice[:0]` 重置切片而不是创建新切片
4. **注意 append 的返回值**：总是使用 `slice = append(slice, ...)` 的形式

```go
package main

import "fmt"

func main() {
    // 预分配容量
    slice := make([]int, 0, 1000)
    for i := 0; i < 1000; i++ {
        slice = append(slice, i)
    }
    fmt.Printf("预分配: len=%d, cap=%d\n", len(slice), cap(slice))
    
    // 避免内存泄漏
    bigSlice := make([]int, 1000000)
    smallSlice := bigSlice[:10:10]  // 限制容量
    fmt.Printf("限制容量: len=%d, cap=%d\n", 
        len(smallSlice), cap(smallSlice))
    
    // 重用切片
    data := []int{1, 2, 3, 4, 5}
    data = data[:0]  // 重置但保留底层数组
    fmt.Printf("重置后: len=%d, cap=%d\n", len(data), cap(data))
}
```

**输出结果：**
```
预分配: len=1000, cap=1000
限制容量: len=10, cap=10
重置后: len=0, cap=5