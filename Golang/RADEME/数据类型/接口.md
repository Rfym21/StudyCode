# Go 接口类型

接口是方法签名的集合，定义了对象的行为规范。

## 接口基础

- 接口是一种类型，定义了一组方法签名
- 任何实现了接口所有方法的类型都隐式地实现了该接口
- 接口变量可以保存任何实现了该接口的值

## 定义和实现接口

```go
package main

import (
    "fmt"
    "math"
)

// 定义接口
type Shape interface {
    Area() float64
    Perimeter() float64
}

// Rectangle 实现 Shape 接口
type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

// Circle 实现 Shape 接口
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius
}

func main() {
    var s Shape
    
    // Rectangle 实现了 Shape
    s = Rectangle{Width: 10, Height: 5}
    fmt.Printf("Rectangle - 面积: %.2f, 周长: %.2f\n", 
        s.Area(), s.Perimeter())
    
    // Circle 也实现了 Shape
    s = Circle{Radius: 3}
    fmt.Printf("Circle - 面积: %.2f, 周长: %.2f\n", 
        s.Area(), s.Perimeter())
    
    // 使用接口切片
    shapes := []Shape{
        Rectangle{Width: 4, Height: 3},
        Circle{Radius: 5},
    }
    
    for i, shape := range shapes {
        fmt.Printf("Shape %d - 面积: %.2f\n", i+1, shape.Area())
    }
}
```

## 空接口

```go
package main

import "fmt"

// 空接口可以保存任何类型的值
func printAny(v interface{}) {
    fmt.Printf("类型: %T, 值: %v\n", v, v)
}

// 使用空接口作为容器
func main() {
    // interface{} 可以保存任何值
    var any interface{}
    
    any = 42
    printAny(any)
    
    any = "Hello"
    printAny(any)
    
    any = true
    printAny(any)
    
    // 空接口切片
    items := []interface{}{1, "hello", 3.14, true}
    for _, item := range items {
        printAny(item)
    }
    
    // 空接口 map
    data := map[string]interface{}{
        "name":   "张三",
        "age":    30,
        "active": true,
    }
    
    for key, value := range data {
        fmt.Printf("%s: %v\n", key, value)
    }
}
```

## 类型断言

```go
package main

import "fmt"

func processValue(v interface{}) {
    // 类型断言
    if str, ok := v.(string); ok {
        fmt.Printf("字符串: %s (长度: %d)\n", str, len(str))
    } else if num, ok := v.(int); ok {
        fmt.Printf("整数: %d (双倍: %d)\n", num, num*2)
    } else if flt, ok := v.(float64); ok {
        fmt.Printf("浮点数: %.2f (平方: %.2f)\n", flt, flt*flt)
    } else {
        fmt.Printf("未知类型: %T\n", v)
    }
}

func main() {
    // 基本类型断言
    var i interface{} = "hello"
    
    // 成功的断言
    s := i.(string)
    fmt.Println(s)
    
    // 带检查的断言
    if n, ok := i.(int); ok {
        fmt.Printf("是整数: %d\n", n)
    } else {
        fmt.Println("不是整数")
    }
    
    // 使用 switch 进行类型断言
    values := []interface{}{42, "world", 3.14, true}
    for _, v := range values {
        switch value := v.(type) {
        case int:
            fmt.Printf("整数: %d\n", value)
        case string:
            fmt.Printf("字符串: %s\n", value)
        case float64:
            fmt.Printf("浮点数: %.2f\n", value)
        case bool:
            fmt.Printf("布尔值: %t\n", value)
        default:
            fmt.Printf("未知类型: %T\n", value)
        }
    }
    
    // 函数中使用
    processValue("Go语言")
    processValue(100)
    processValue(3.14159)
}
```

## 接口组合

```go
package main

import "fmt"

// 基础接口
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

// 组合接口
type ReadWriter interface {
    Reader
    Writer
}

// 更复杂的组合
type Closer interface {
    Close() error
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

// 实现示例
type File struct {
    name string
}

func (f *File) Read(p []byte) (int, error) {
    fmt.Printf("Reading from %s\n", f.name)
    return len(p), nil
}

func (f *File) Write(p []byte) (int, error) {
    fmt.Printf("Writing to %s\n", f.name)
    return len(p), nil
}

func (f *File) Close() error {
    fmt.Printf("Closing %s\n", f.name)
    return nil
}

func main() {
    file := &File{name: "test.txt"}
    
    // File 实现了 ReadWriteCloser
    var rwc ReadWriteCloser = file
    
    // 使用接口方法
    rwc.Read(make([]byte, 10))
    rwc.Write([]byte("hello"))
    rwc.Close()
    
    // 也可以作为 Reader 使用
    var r Reader = file
    r.Read(make([]byte, 10))
}
```

## 接口的实际应用

```go
package main

import (
    "fmt"
    "sort"
)

// 1. 排序接口
type Person struct {
    Name string
    Age  int
}

type ByAge []Person

func (a ByAge) Len() int           { return len(a) }
func (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }

// 2. Stringer 接口
func (p Person) String() string {
    return fmt.Sprintf("%s (%d岁)", p.Name, p.Age)
}

// 3. 错误接口
type MyError struct {
    Code    int
    Message string
}

func (e MyError) Error() string {
    return fmt.Sprintf("错误 %d: %s", e.Code, e.Message)
}

// 4. 自定义接口
type Logger interface {
    Log(message string)
}

type ConsoleLogger struct{}

func (c ConsoleLogger) Log(message string) {
    fmt.Println("[Console]", message)
}

type FileLogger struct {
    filename string
}

func (f FileLogger) Log(message string) {
    fmt.Printf("[File: %s] %s\n", f.filename, message)
}

func doSomething(logger Logger) {
    logger.Log("开始处理")
    // ... 业务逻辑
    logger.Log("处理完成")
}

func main() {
    // 使用排序接口
    people := []Person{
        {"Alice", 30},
        {"Bob", 25},
        {"Charlie", 35},
    }
    
    fmt.Println("排序前:", people)
    sort.Sort(ByAge(people))
    fmt.Println("排序后:", people)
    
    // Stringer 接口会被 fmt 包自动调用
    fmt.Println("\n使用 Stringer:")
    for _, p := range people {
        fmt.Println(p)  // 调用 String() 方法
    }
    
    // 错误接口
    err := MyError{Code: 404, Message: "未找到"}
    fmt.Printf("\n错误: %v\n", err)
    
    // 使用不同的 Logger 实现
    fmt.Println("\n日志示例:")
    doSomething(ConsoleLogger{})
    doSomething(FileLogger{filename: "app.log"})
}
```

## 接口与 nil

```go
package main

import "fmt"

type Animal interface {
    Speak() string
}

type Dog struct {
    Name string
}

func (d *Dog) Speak() string {
    if d == nil {
        return "<nil dog>"
    }
    return d.Name + " says woof!"
}

func main() {
    // nil 接口值
    var a Animal
    fmt.Printf("a == nil: %t\n", a == nil)  // true
    
    // 接口值包含 nil 具体值
    var d *Dog
    a = d
    fmt.Printf("a == nil: %t\n", a == nil)  // false!
    fmt.Printf("a 的类型: %T\n", a)          // *main.Dog
    fmt.Println("a.Speak():", a.Speak())     // 可以调用
    
    // 正确检查接口是否为 nil
    if a != nil {
        // 检查具体值是否为 nil
        if dog, ok := a.(*Dog); ok && dog == nil {
            fmt.Println("接口包含 nil *Dog")
        }
    }
}
```

## 接口设计原则

```go
package main

import (
    "fmt"
    "io"
)

// 1. 小接口原则
type Printer interface {
    Print()
}

// 2. 接口隔离原则
type Document interface {
    Printer
    Save() error
}

// 3. 依赖倒置原则
type DataProcessor struct {
    reader io.Reader
    writer io.Writer
}

func NewDataProcessor(r io.Reader, w io.Writer) *DataProcessor {
    return &DataProcessor{
        reader: r,
        writer: w,
    }
}

func (dp *DataProcessor) Process() error {
    data := make([]byte, 1024)
    n, err := dp.reader.Read(data)
    if err != nil {
        return err
    }
    
    _, err = dp.writer.Write(data[:n])
    return err
}

// 4. 面向接口编程
type Cache interface {
    Get(key string) (interface{}, bool)
    Set(key string, value interface{})
}

type MemoryCache struct {
    data map[string]interface{}
}

func NewMemoryCache() Cache {
    return &MemoryCache{
        data: make(map[string]interface{}),
    }
}

func (m *MemoryCache) Get(key string) (interface{}, bool) {
    value, exists := m.data[key]
    return value, exists
}

func (m *MemoryCache) Set(key string, value interface{}) {
    m.data[key] = value
}

func main() {
    // 使用接口而不是具体类型
    var cache Cache = NewMemoryCache()
    
    cache.Set("name", "Go")
    if value, ok := cache.Get("name"); ok {
        fmt.Printf("缓存值: %v\n", value)
    }
}
```

## 最佳实践

1. **接口应该小而精**：单一职责原则
2. **先定义类型，再抽象接口**：避免过度设计
3. **接受接口，返回具体类型**：增加灵活性
4. **避免空接口滥用**：尽量使用具体类型
5. **接口命名**：
   - 单方法接口通常以 -er 结尾（Reader, Writer）
   - 避免 IXxx 这样的命名方式
6. **检查接口实现**：使用编译时断言
   ```go
   var _ MyInterface = (*MyType)(nil)