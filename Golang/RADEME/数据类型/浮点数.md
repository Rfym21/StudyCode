# Go 浮点数类型

Go 提供了两种浮点数类型，遵循 IEEE-754 标准。

## 浮点数类型

- `float32`: 32位浮点数（IEEE-754 标准）
  - 精度：大约 6-7 位有效数字
  - 范围：±1.18e-38 到 ±3.4e38
  
- `float64`: 64位浮点数（IEEE-754 标准）
  - 精度：大约 15-17 位有效数字
  - 范围：±2.23e-308 到 ±1.80e308

## 基本使用

```go
package main

import "fmt"

func main() {
    var f1 float32 = 3.14159
    var f2 float64 = 3.141592653589793

    fmt.Printf("float32: %.5f\n", f1)
    fmt.Printf("float64: %.15f\n", f2)

    // 科学计数法
    var scientific float64 = 1.23e4  // 12300
    fmt.Printf("科学计数法: %.2f\n", scientific)
}
```

## 特殊值

浮点数支持几个特殊值：

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    // 正无穷
    posInf := math.Inf(1)
    fmt.Printf("正无穷: %v\n", posInf)
    
    // 负无穷
    negInf := math.Inf(-1)
    fmt.Printf("负无穷: %v\n", negInf)
    
    // NaN (Not a Number)
    nan := math.NaN()
    fmt.Printf("NaN: %v\n", nan)
    
    // 检查特殊值
    fmt.Printf("是否为无穷: %v\n", math.IsInf(posInf, 1))
    fmt.Printf("是否为NaN: %v\n", math.IsNaN(nan))
}
```

## 精度问题

浮点数运算可能存在精度问题：

```go
package main

import "fmt"

func main() {
    var a float64 = 0.1
    var b float64 = 0.2
    var c float64 = a + b
    
    fmt.Printf("0.1 + 0.2 = %.17f\n", c)
    // 输出可能是: 0.1 + 0.2 = 0.30000000000000004
    
    // 比较浮点数时应该使用误差范围
    epsilon := 1e-9
    if math.Abs(c - 0.3) < epsilon {
        fmt.Println("相等（在误差范围内）")
    }
}
```

## 使用建议

1. **默认使用 `float64`**：除非有特殊的内存限制，否则使用 `float64` 以获得更高的精度
2. **避免直接比较**：不要使用 `==` 直接比较浮点数，而应该检查它们的差值是否在可接受的误差范围内
3. **金融计算**：对于需要精确计算的场景（如金融），考虑使用整数（分为单位）或专门的十进制库
4. **性能考虑**：`float32` 在某些情况下可能更快，特别是在 GPU 计算中